{
  "magicNumber": 1635018093,
  "metadata": {
    "MetadataV4": {
      "modules": [
        {
          "name": "system",
          "prefix": "System",
          "storage": [
            {
              "name": "AccountNonce",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "Index",
                  "isLinked": false
                }
              },
              "fallback": "0x0000000000000000",
              "documentation": [
                " Extrinsics nonce for accounts."
              ]
            },
            {
              "name": "ExtrinsicCount",
              "modifier": "Optional",
              "type": {
                "PlainType": "u32"
              },
              "fallback": "0x00",
              "documentation": [
                " Total extrinsics count for the current block."
              ]
            },
            {
              "name": "AllExtrinsicsLen",
              "modifier": "Optional",
              "type": {
                "PlainType": "u32"
              },
              "fallback": "0x00",
              "documentation": [
                " Total length in bytes for all extrinsics put together, for the current block."
              ]
            },
            {
              "name": "BlockHash",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "BlockNumber",
                  "value": "Hash",
                  "isLinked": false
                }
              },
              "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
              "documentation": [
                " Map of block numbers to block hashes."
              ]
            },
            {
              "name": "ExtrinsicData",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "u32",
                  "value": "Bytes",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " Extrinsics data for the current block (maps an extrinsic's index to its data)."
              ]
            },
            {
              "name": "RandomMaterial",
              "modifier": "Default",
              "type": {
                "PlainType": "(i8,Vec<Hash>)"
              },
              "fallback": "0x0000",
              "documentation": [
                " Series of block headers from the last 81 blocks that acts as random seed material. This is arranged as a",
                " ring buffer with the `i8` prefix being the index into the `Vec` of the oldest hash."
              ]
            },
            {
              "name": "Number",
              "modifier": "Default",
              "type": {
                "PlainType": "BlockNumber"
              },
              "fallback": "0x0000000000000000",
              "documentation": [
                " The current block number being processed. Set by `execute_block`."
              ]
            },
            {
              "name": "ParentHash",
              "modifier": "Default",
              "type": {
                "PlainType": "Hash"
              },
              "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
              "documentation": [
                " Hash of the previous block."
              ]
            },
            {
              "name": "ExtrinsicsRoot",
              "modifier": "Default",
              "type": {
                "PlainType": "Hash"
              },
              "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
              "documentation": [
                " Extrinsics root of the current block, also part of the block header."
              ]
            },
            {
              "name": "Digest",
              "modifier": "Default",
              "type": {
                "PlainType": "Digest"
              },
              "fallback": "0x00",
              "documentation": [
                " Digest of the current block, also part of the block header."
              ]
            },
            {
              "name": "Events",
              "modifier": "Default",
              "type": {
                "PlainType": "Vec<EventRecord>"
              },
              "fallback": "0x00",
              "documentation": [
                " Events deposited for the current block."
              ]
            },
            {
              "name": "EventCount",
              "modifier": "Default",
              "type": {
                "PlainType": "EventIndex"
              },
              "fallback": "0x00000000",
              "documentation": [
                " The number of events in the `Events<T>` list."
              ]
            },
            {
              "name": "EventTopics",
              "modifier": "Default",
              "type": {
                "DoubleMapType": {
                  "hasher": "Blake2_256",
                  "key1": "Null",
                  "key2": "Hash",
                  "value": "Vec<(BlockNumber,EventIndex)>",
                  "key2Hasher": "blake2_256"
                }
              },
              "fallback": "0x00",
              "documentation": [
                " Mapping between a topic (represented by T::Hash) and a vector of indexes",
                " of events in the `<Events<T>>` list.",
                "",
                " The first key serves no purpose. This field is declared as double_map just",
                " for convenience of using `remove_prefix`.",
                "",
                " All topic vectors have deterministic storage locations depending on the topic. This",
                " allows light-clients to leverage the changes trie storage tracking mechanism and",
                " in case of changes fetch the list of events of interest.",
                "",
                " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just",
                " the `EventIndex` then in case if the topic has the same contents on the next block",
                " no notification will be triggered thus the event might be lost."
              ]
            }
          ],
          "calls": null,
          "events": [
            {
              "name": "ExtrinsicSuccess",
              "args": [],
              "documentation": [
                " An extrinsic completed successfully."
              ]
            },
            {
              "name": "ExtrinsicFailed",
              "args": [],
              "documentation": [
                " An extrinsic failed."
              ]
            }
          ]
        },
        {
          "name": "aura",
          "prefix": "",
          "storage": null,
          "calls": null,
          "events": null
        },
        {
          "name": "timestamp",
          "prefix": "Timestamp",
          "storage": [
            {
              "name": "Now",
              "modifier": "Default",
              "type": {
                "PlainType": "Moment"
              },
              "fallback": "0x0000000000000000",
              "documentation": [
                " Current time for the current block."
              ]
            },
            {
              "name": "BlockPeriod",
              "modifier": "Optional",
              "type": {
                "PlainType": "Moment"
              },
              "fallback": "0x00",
              "documentation": [
                " Old storage item provided for compatibility. Remove after all networks upgraded."
              ]
            },
            {
              "name": "MinimumPeriod",
              "modifier": "Default",
              "type": {
                "PlainType": "Moment"
              },
              "fallback": "0x0300000000000000",
              "documentation": [
                " The minimum period between blocks. Beware that this is different to the *expected* period",
                " that the block production apparatus provides. Your chosen consensus system will generally",
                " work with this to determine a sensible block time. e.g. For Aura, it will be double this",
                " period on default settings."
              ]
            },
            {
              "name": "DidUpdate",
              "modifier": "Default",
              "type": {
                "PlainType": "bool"
              },
              "fallback": "0x00",
              "documentation": [
                " Did the timestamp get updated in this block?"
              ]
            }
          ],
          "calls": [
            {
              "name": "set",
              "args": [
                {
                  "name": "now",
                  "type": "Compact<Moment>"
                }
              ],
              "documentation": [
                " Set the current time.",
                "",
                " This call should be invoked exactly once per block. It will panic at the finalization phase,",
                " if this call hasn't been invoked by that time.",
                "",
                " The timestamp should be greater than the previous one by the amount specified by `minimum_period`.",
                "",
                " The dispatch origin for this call must be `Inherent`."
              ]
            }
          ],
          "events": null
        },
        {
          "name": "consensus",
          "prefix": "Consensus",
          "storage": [
            {
              "name": "OriginalAuthorities",
              "modifier": "Optional",
              "type": {
                "PlainType": "Vec<SessionKey>"
              },
              "fallback": "0x00",
              "documentation": []
            }
          ],
          "calls": [
            {
              "name": "report_misbehavior",
              "args": [
                {
                  "name": "_report",
                  "type": "Bytes"
                }
              ],
              "documentation": [
                " Report some misbehavior."
              ]
            },
            {
              "name": "note_offline",
              "args": [
                {
                  "name": "offline",
                  "type": "InherentOfflineReport"
                }
              ],
              "documentation": [
                " Note that the previous block's validator missed its opportunity to propose a block."
              ]
            },
            {
              "name": "remark",
              "args": [
                {
                  "name": "_remark",
                  "type": "Bytes"
                }
              ],
              "documentation": [
                " Make some on-chain remark."
              ]
            },
            {
              "name": "set_heap_pages",
              "args": [
                {
                  "name": "pages",
                  "type": "u64"
                }
              ],
              "documentation": [
                " Set the number of pages in the WebAssembly environment's heap."
              ]
            },
            {
              "name": "set_code",
              "args": [
                {
                  "name": "new",
                  "type": "Bytes"
                }
              ],
              "documentation": [
                " Set the new code."
              ]
            },
            {
              "name": "set_storage",
              "args": [
                {
                  "name": "items",
                  "type": "Vec<KeyValue>"
                }
              ],
              "documentation": [
                " Set some items of storage."
              ]
            },
            {
              "name": "kill_storage",
              "args": [
                {
                  "name": "keys",
                  "type": "Vec<Key>"
                }
              ],
              "documentation": [
                " Kill some items from storage."
              ]
            }
          ],
          "events": null
        },
        {
          "name": "indices",
          "prefix": "Indices",
          "storage": [
            {
              "name": "NextEnumSet",
              "modifier": "Default",
              "type": {
                "PlainType": "AccountIndex"
              },
              "fallback": "0x00000000",
              "documentation": [
                " The next free enumeration set."
              ]
            },
            {
              "name": "EnumSet",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountIndex",
                  "value": "Vec<AccountId>",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " The enumeration sets."
              ]
            }
          ],
          "calls": [],
          "events": [
            {
              "name": "NewAccountIndex",
              "args": [
                "AccountId",
                "AccountIndex"
              ],
              "documentation": [
                " A new account index was assigned.",
                "",
                " This event is not triggered when an existing index is reassigned",
                " to another `AccountId`."
              ]
            }
          ]
        },
        {
          "name": "balances",
          "prefix": "Balances",
          "storage": [
            {
              "name": "TotalIssuance",
              "modifier": "Default",
              "type": {
                "PlainType": "Balance"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " The total units issued in the system."
              ]
            },
            {
              "name": "ExistentialDeposit",
              "modifier": "Default",
              "type": {
                "PlainType": "Balance"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " The minimum amount required to keep an account open."
              ]
            },
            {
              "name": "TransferFee",
              "modifier": "Default",
              "type": {
                "PlainType": "Balance"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " The fee required to make a transfer."
              ]
            },
            {
              "name": "CreationFee",
              "modifier": "Default",
              "type": {
                "PlainType": "Balance"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " The fee required to create an account."
              ]
            },
            {
              "name": "TransactionBaseFee",
              "modifier": "Default",
              "type": {
                "PlainType": "Balance"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " The fee to be paid for making a transaction; the base."
              ]
            },
            {
              "name": "TransactionByteFee",
              "modifier": "Default",
              "type": {
                "PlainType": "Balance"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " The fee to be paid for making a transaction; the per-byte portion."
              ]
            },
            {
              "name": "Vesting",
              "modifier": "Optional",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "VestingSchedule",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " Information regarding the vesting of a given account."
              ]
            },
            {
              "name": "FreeBalance",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "Balance",
                  "isLinked": false
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " The 'free' balance of a given account.",
                "",
                " This is the only balance that matters in terms of most operations on tokens. It",
                " alone is used to determine the balance when in the contract execution environment. When this",
                " balance falls below the value of `ExistentialDeposit`, then the 'current account' is",
                " deleted: specifically `FreeBalance`. Further, the `OnFreeBalanceZero` callback",
                " is invoked, giving a chance to external modules to clean up data associated with",
                " the deleted account.",
                "",
                " `system::AccountNonce` is also deleted if `ReservedBalance` is also zero (it also gets",
                " collapsed to zero if it ever becomes less than `ExistentialDeposit`."
              ]
            },
            {
              "name": "ReservedBalance",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "Balance",
                  "isLinked": false
                }
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " The amount of the balance of a given account that is externally reserved; this can still get",
                " slashed, but gets slashed last of all.",
                "",
                " This balance is a 'reserve' balance that other subsystems use in order to set aside tokens",
                " that are still 'owned' by the account holder, but which are suspendable.",
                "",
                " When this balance falls below the value of `ExistentialDeposit`, then this 'reserve account'",
                " is deleted: specifically, `ReservedBalance`.",
                "",
                " `system::AccountNonce` is also deleted if `FreeBalance` is also zero (it also gets",
                " collapsed to zero if it ever becomes less than `ExistentialDeposit`.)"
              ]
            },
            {
              "name": "Locks",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "Vec<BalanceLock>",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " Any liquidity locks on some account balances."
              ]
            }
          ],
          "calls": [
            {
              "name": "transfer",
              "args": [
                {
                  "name": "dest",
                  "type": "Address"
                },
                {
                  "name": "value",
                  "type": "Compact<Balance>"
                }
              ],
              "documentation": [
                " Transfer some liquid free balance to another account.",
                "",
                " `transfer` will set the `FreeBalance` of the sender and receiver.",
                " It will decrease the total issuance of the system by the `TransferFee`.",
                " If the sender's account is below the existential deposit as a result",
                " of the transfer, the account will be reaped.",
                "",
                " The dispatch origin for this call must be `Signed` by the transactor."
              ]
            },
            {
              "name": "set_balance",
              "args": [
                {
                  "name": "who",
                  "type": "Address"
                },
                {
                  "name": "free",
                  "type": "Compact<Balance>"
                },
                {
                  "name": "reserved",
                  "type": "Compact<Balance>"
                }
              ],
              "documentation": [
                " Set the balances of a given account.",
                "",
                " This will alter `FreeBalance` and `ReservedBalance` in storage.",
                " If the new free or reserved balance is below the existential deposit,",
                " it will also decrease the total issuance of the system (`TotalIssuance`)",
                " and reset the account nonce (`system::AccountNonce`).",
                "",
                " The dispatch origin for this call is `root`."
              ]
            }
          ],
          "events": [
            {
              "name": "NewAccount",
              "args": [
                "AccountId",
                "Balance"
              ],
              "documentation": [
                " A new account was created."
              ]
            },
            {
              "name": "ReapedAccount",
              "args": [
                "AccountId"
              ],
              "documentation": [
                " An account was reaped."
              ]
            },
            {
              "name": "Transfer",
              "args": [
                "AccountId",
                "AccountId",
                "Balance",
                "Balance"
              ],
              "documentation": [
                " Transfer succeeded (from, to, value, fees)."
              ]
            }
          ]
        },
        {
          "name": "session",
          "prefix": "Session",
          "storage": [
            {
              "name": "Validators",
              "modifier": "Default",
              "type": {
                "PlainType": "Vec<AccountId>"
              },
              "fallback": "0x00",
              "documentation": [
                " The current set of validators."
              ]
            },
            {
              "name": "SessionLength",
              "modifier": "Default",
              "type": {
                "PlainType": "BlockNumber"
              },
              "fallback": "0xe803000000000000",
              "documentation": [
                " Current length of the session."
              ]
            },
            {
              "name": "CurrentIndex",
              "modifier": "Default",
              "type": {
                "PlainType": "BlockNumber"
              },
              "fallback": "0x0000000000000000",
              "documentation": [
                " Current index of the session."
              ]
            },
            {
              "name": "CurrentStart",
              "modifier": "Default",
              "type": {
                "PlainType": "Moment"
              },
              "fallback": "0x0000000000000000",
              "documentation": [
                " Timestamp when current session started."
              ]
            },
            {
              "name": "ForcingNewSession",
              "modifier": "Optional",
              "type": {
                "PlainType": "bool"
              },
              "fallback": "0x00",
              "documentation": [
                " New session is being forced if this entry exists; in which case, the boolean value is true if",
                " the new session should be considered a normal rotation (rewardable) and false if the new session",
                " should be considered exceptional (slashable)."
              ]
            },
            {
              "name": "LastLengthChange",
              "modifier": "Optional",
              "type": {
                "PlainType": "BlockNumber"
              },
              "fallback": "0x00",
              "documentation": [
                " Block at which the session length last changed."
              ]
            },
            {
              "name": "NextKeyFor",
              "modifier": "Optional",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "SessionKey",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " The next key for a given validator."
              ]
            },
            {
              "name": "NextSessionLength",
              "modifier": "Optional",
              "type": {
                "PlainType": "BlockNumber"
              },
              "fallback": "0x00",
              "documentation": [
                " The next session length."
              ]
            }
          ],
          "calls": [
            {
              "name": "set_key",
              "args": [
                {
                  "name": "key",
                  "type": "SessionKey"
                }
              ],
              "documentation": [
                " Sets the session key of a validator (function caller) to `key`.",
                " This doesn't take effect until the next session."
              ]
            },
            {
              "name": "set_length",
              "args": [
                {
                  "name": "new",
                  "type": "Compact<BlockNumber>"
                }
              ],
              "documentation": [
                " Set a new session length. Won't kick in until the next session change (at current length)."
              ]
            },
            {
              "name": "force_new_session",
              "args": [
                {
                  "name": "apply_rewards",
                  "type": "bool"
                }
              ],
              "documentation": [
                " Forces a new session."
              ]
            }
          ],
          "events": [
            {
              "name": "NewSession",
              "args": [
                "BlockNumber"
              ],
              "documentation": [
                " New session has happened. Note that the argument is the session index, not the block",
                " number as the type might suggest."
              ]
            }
          ]
        },
        {
          "name": "staking",
          "prefix": "Staking",
          "storage": [
            {
              "name": "ValidatorCount",
              "modifier": "Default",
              "type": {
                "PlainType": "u32"
              },
              "fallback": "0x00000000",
              "documentation": [
                " The ideal number of staking participants."
              ]
            },
            {
              "name": "MinimumValidatorCount",
              "modifier": "Default",
              "type": {
                "PlainType": "u32"
              },
              "fallback": "0x04000000",
              "documentation": [
                " Minimum number of staking participants before emergency conditions are imposed."
              ]
            },
            {
              "name": "SessionsPerEra",
              "modifier": "Default",
              "type": {
                "PlainType": "BlockNumber"
              },
              "fallback": "0xe803000000000000",
              "documentation": [
                " The length of a staking era in sessions."
              ]
            },
            {
              "name": "SessionReward",
              "modifier": "Default",
              "type": {
                "PlainType": "Perbill"
              },
              "fallback": "0x3c000000",
              "documentation": [
                " Maximum reward, per validator, that is provided per acceptable session."
              ]
            },
            {
              "name": "OfflineSlash",
              "modifier": "Default",
              "type": {
                "PlainType": "Perbill"
              },
              "fallback": "0x40420f00",
              "documentation": [
                " Slash, per validator that is taken for the first time they are found to be offline."
              ]
            },
            {
              "name": "OfflineSlashGrace",
              "modifier": "Default",
              "type": {
                "PlainType": "u32"
              },
              "fallback": "0x00000000",
              "documentation": [
                " Number of instances of offline reports before slashing begins for validators."
              ]
            },
            {
              "name": "BondingDuration",
              "modifier": "Default",
              "type": {
                "PlainType": "BlockNumber"
              },
              "fallback": "0x0c00000000000000",
              "documentation": [
                " The length of the bonding duration in eras."
              ]
            },
            {
              "name": "Invulnerables",
              "modifier": "Default",
              "type": {
                "PlainType": "Vec<AccountId>"
              },
              "fallback": "0x00",
              "documentation": [
                " Any validators that may never be slashed or forcibly kicked. It's a Vec since they're easy to initialize",
                " and the performance hit is minimal (we expect no more than four invulnerables) and restricted to testnets."
              ]
            },
            {
              "name": "Bonded",
              "modifier": "Optional",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "AccountId",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " Map from all locked \"stash\" accounts to the controller account."
              ]
            },
            {
              "name": "Ledger",
              "modifier": "Optional",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "StakingLedger",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " Map from all (unlocked) \"controller\" accounts to the info regarding the staking."
              ]
            },
            {
              "name": "Payee",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "RewardDestination",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " Where the reward payment should be made. Keyed by stash."
              ]
            },
            {
              "name": "Validators",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "ValidatorPrefs",
                  "isLinked": true
                }
              },
              "fallback": "0x0c00",
              "documentation": [
                " The map from (wannabe) validator stash key to the preferences of that validator."
              ]
            },
            {
              "name": "Nominators",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "Vec<AccountId>",
                  "isLinked": true
                }
              },
              "fallback": "0x00",
              "documentation": [
                " The map from nominator stash key to the set of stash keys of all validators to nominate."
              ]
            },
            {
              "name": "Stakers",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "Exposure",
                  "isLinked": false
                }
              },
              "fallback": "0x000000",
              "documentation": [
                " Nominators for a particular account that is in action right now. You can't iterate through validators here,",
                " but you can find them in the Session module.",
                "",
                " This is keyed by the stash account."
              ]
            },
            {
              "name": "CurrentElected",
              "modifier": "Default",
              "type": {
                "PlainType": "Vec<AccountId>"
              },
              "fallback": "0x00",
              "documentation": [
                " The currently elected validator set keyed by stash account ID."
              ]
            },
            {
              "name": "CurrentEra",
              "modifier": "Default",
              "type": {
                "PlainType": "BlockNumber"
              },
              "fallback": "0x0000000000000000",
              "documentation": [
                " The current era index."
              ]
            },
            {
              "name": "CurrentSessionReward",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " Maximum reward, per validator, that is provided per acceptable session."
              ]
            },
            {
              "name": "CurrentEraReward",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " The accumulated reward for the current era. Reset to zero at the beginning of the era and",
                " increased for every successfully finished session."
              ]
            },
            {
              "name": "NextSessionsPerEra",
              "modifier": "Optional",
              "type": {
                "PlainType": "BlockNumber"
              },
              "fallback": "0x00",
              "documentation": [
                " The next value of sessions per era."
              ]
            },
            {
              "name": "LastEraLengthChange",
              "modifier": "Default",
              "type": {
                "PlainType": "BlockNumber"
              },
              "fallback": "0x0000000000000000",
              "documentation": [
                " The session index at which the era length last changed."
              ]
            },
            {
              "name": "SlotStake",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " The amount of balance actively at stake for each validator slot, currently.",
                "",
                " This is used to derive rewards and punishments."
              ]
            },
            {
              "name": "SlashCount",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "u32",
                  "isLinked": false
                }
              },
              "fallback": "0x00000000",
              "documentation": [
                " The number of times a given validator has been reported offline. This gets decremented by one each era that passes."
              ]
            },
            {
              "name": "ForcingNewEra",
              "modifier": "Optional",
              "type": {
                "PlainType": "Null"
              },
              "fallback": "0x00",
              "documentation": [
                " We are forcing a new era."
              ]
            },
            {
              "name": "RecentlyOffline",
              "modifier": "Default",
              "type": {
                "PlainType": "Vec<(AccountId,BlockNumber,u32)>"
              },
              "fallback": "0x00",
              "documentation": [
                " Most recent `RECENT_OFFLINE_COUNT` instances. (Who it was, when it was reported, how many instances they were offline for)."
              ]
            }
          ],
          "calls": [
            {
              "name": "bond",
              "args": [
                {
                  "name": "controller",
                  "type": "Address"
                },
                {
                  "name": "value",
                  "type": "Compact<BalanceOf>"
                },
                {
                  "name": "payee",
                  "type": "RewardDestination"
                }
              ],
              "documentation": [
                " Take the origin account as a stash and lock up `value` of its balance. `controller` will be the",
                " account that controls it.",
                "",
                " The dispatch origin for this call must be _Signed_ by the stash account."
              ]
            },
            {
              "name": "bond_extra",
              "args": [
                {
                  "name": "max_additional",
                  "type": "Compact<BalanceOf>"
                }
              ],
              "documentation": [
                " Add some extra amount that have appeared in the stash `free_balance` into the balance up for",
                " staking.",
                "",
                " Use this if there are additional funds in your stash account that you wish to bond.",
                "",
                " The dispatch origin for this call must be _Signed_ by the stash, not the controller."
              ]
            },
            {
              "name": "unbond",
              "args": [
                {
                  "name": "value",
                  "type": "Compact<BalanceOf>"
                }
              ],
              "documentation": [
                " Schedule a portion of the stash to be unlocked ready for transfer out after the bond",
                " period ends. If this leaves an amount actively bonded less than",
                " T::Currency::existential_deposit(), then it is increased to the full amount.",
                "",
                " Once the unlock period is done, you can call `withdraw_unbonded` to actually move",
                " the funds out of management ready for transfer.",
                "",
                " No more than a limited number of unlocking chunks (see `MAX_UNLOCKING_CHUNKS`)",
                " can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need",
                " to be called first to remove some of the chunks (if possible).",
                "",
                " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
                "",
                " See also [`Call::withdraw_unbonded`]."
              ]
            },
            {
              "name": "withdraw_unbonded",
              "args": [],
              "documentation": [
                " Remove any unlocked chunks from the `unlocking` queue from our management.",
                "",
                " This essentially frees up that balance to be used by the stash account to do",
                " whatever it wants.",
                "",
                " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
                "",
                " See also [`Call::unbond`]."
              ]
            },
            {
              "name": "validate",
              "args": [
                {
                  "name": "prefs",
                  "type": "ValidatorPrefs"
                }
              ],
              "documentation": [
                " Declare the desire to validate for the origin controller.",
                "",
                " Effects will be felt at the beginning of the next era.",
                "",
                " The dispatch origin for this call must be _Signed_ by the controller, not the stash."
              ]
            },
            {
              "name": "nominate",
              "args": [
                {
                  "name": "targets",
                  "type": "Vec<Address>"
                }
              ],
              "documentation": [
                " Declare the desire to nominate `targets` for the origin controller.",
                "",
                " Effects will be felt at the beginning of the next era.",
                "",
                " The dispatch origin for this call must be _Signed_ by the controller, not the stash."
              ]
            },
            {
              "name": "chill",
              "args": [],
              "documentation": [
                " Declare no desire to either validate or nominate.",
                "",
                " Effects will be felt at the beginning of the next era.",
                "",
                " The dispatch origin for this call must be _Signed_ by the controller, not the stash."
              ]
            },
            {
              "name": "set_payee",
              "args": [
                {
                  "name": "payee",
                  "type": "RewardDestination"
                }
              ],
              "documentation": [
                " (Re-)set the payment target for a controller.",
                "",
                " Effects will be felt at the beginning of the next era.",
                "",
                " The dispatch origin for this call must be _Signed_ by the controller, not the stash."
              ]
            },
            {
              "name": "set_controller",
              "args": [
                {
                  "name": "controller",
                  "type": "Address"
                }
              ],
              "documentation": [
                " (Re-)set the payment target for a controller.",
                "",
                " Effects will be felt at the beginning of the next era.",
                "",
                " The dispatch origin for this call must be _Signed_ by the stash, not the controller."
              ]
            },
            {
              "name": "set_sessions_per_era",
              "args": [
                {
                  "name": "new",
                  "type": "Compact<BlockNumber>"
                }
              ],
              "documentation": [
                " Set the number of sessions in an era."
              ]
            },
            {
              "name": "set_bonding_duration",
              "args": [
                {
                  "name": "new",
                  "type": "Compact<BlockNumber>"
                }
              ],
              "documentation": [
                " The length of the bonding duration in eras."
              ]
            },
            {
              "name": "set_validator_count",
              "args": [
                {
                  "name": "new",
                  "type": "Compact<u32>"
                }
              ],
              "documentation": [
                " The ideal number of validators."
              ]
            },
            {
              "name": "force_new_era",
              "args": [
                {
                  "name": "apply_rewards",
                  "type": "bool"
                }
              ],
              "documentation": [
                " Force there to be a new era. This also forces a new session immediately after.",
                " `apply_rewards` should be true for validators to get the session reward."
              ]
            },
            {
              "name": "set_offline_slash_grace",
              "args": [
                {
                  "name": "new",
                  "type": "Compact<u32>"
                }
              ],
              "documentation": [
                " Set the offline slash grace period."
              ]
            },
            {
              "name": "set_invulnerables",
              "args": [
                {
                  "name": "validators",
                  "type": "Vec<AccountId>"
                }
              ],
              "documentation": [
                " Set the validators who cannot be slashed (if any)."
              ]
            }
          ],
          "events": [
            {
              "name": "Reward",
              "args": [
                "Balance"
              ],
              "documentation": [
                " All validators have been rewarded by the given balance."
              ]
            },
            {
              "name": "OfflineWarning",
              "args": [
                "AccountId",
                "u32"
              ],
              "documentation": [
                " One validator (and its nominators) has been given an offline-warning (it is still",
                " within its grace). The accrued number of slashes is recorded, too."
              ]
            },
            {
              "name": "OfflineSlash",
              "args": [
                "AccountId",
                "Balance"
              ],
              "documentation": [
                " One validator (and its nominators) has been slashed by the given amount."
              ]
            }
          ]
        },
        {
          "name": "democracy",
          "prefix": "Democracy",
          "storage": [
            {
              "name": "PublicPropCount",
              "modifier": "Default",
              "type": {
                "PlainType": "PropIndex"
              },
              "fallback": "0x00000000",
              "documentation": [
                " The number of (public) proposals that have been made so far."
              ]
            },
            {
              "name": "PublicProps",
              "modifier": "Default",
              "type": {
                "PlainType": "Vec<(PropIndex,Proposal,AccountId)>"
              },
              "fallback": "0x00",
              "documentation": [
                " The public proposals. Unsorted."
              ]
            },
            {
              "name": "DepositOf",
              "modifier": "Optional",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "PropIndex",
                  "value": "(BalanceOf,Vec<AccountId>)",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " Those who have locked a deposit."
              ]
            },
            {
              "name": "ReferendumCount",
              "modifier": "Default",
              "type": {
                "PlainType": "ReferendumIndex"
              },
              "fallback": "0x00000000",
              "documentation": [
                " The next free referendum index, aka the number of referenda started so far."
              ]
            },
            {
              "name": "NextTally",
              "modifier": "Default",
              "type": {
                "PlainType": "ReferendumIndex"
              },
              "fallback": "0x00000000",
              "documentation": [
                " The next referendum index that should be tallied."
              ]
            },
            {
              "name": "ReferendumInfoOf",
              "modifier": "Optional",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "ReferendumIndex",
                  "value": "ReferendumInfo",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " Information concerning any given referendum."
              ]
            },
            {
              "name": "DispatchQueue",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "BlockNumber",
                  "value": "Vec<Option<(Proposal,ReferendumIndex)>>",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " Queue of successful referenda to be dispatched."
              ]
            },
            {
              "name": "VotersFor",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "ReferendumIndex",
                  "value": "Vec<AccountId>",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " Get the voters for the current proposal."
              ]
            },
            {
              "name": "VoteOf",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "(ReferendumIndex,AccountId)",
                  "value": "Vote",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " Get the vote in a given referendum of a particular voter. The result is meaningful only",
                " if `voters_for` includes the voter when called with the referendum (you'll get the",
                " default `Vote` value otherwise). If you don't want to check `voters_for`, then you can",
                " also check for simple existence with `VoteOf::exists` first."
              ]
            },
            {
              "name": "Proxy",
              "modifier": "Optional",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "AccountId",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " Who is able to vote for whom. Value is the fund-holding account, key is the",
                " vote-transaction-sending account."
              ]
            },
            {
              "name": "Delegations",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "(AccountId,Conviction)",
                  "isLinked": true
                }
              },
              "fallback": "0x000000000000000000000000000000000000000000000000000000000000000000",
              "documentation": [
                " Get the account (and lock periods) to which another account is delegating vote."
              ]
            },
            {
              "name": "LastTabledWasExternal",
              "modifier": "Default",
              "type": {
                "PlainType": "bool"
              },
              "fallback": "0x00",
              "documentation": [
                " True if the last referendum tabled was submitted externally. False if it was a public",
                " proposal."
              ]
            },
            {
              "name": "NextExternal",
              "modifier": "Optional",
              "type": {
                "PlainType": "(Proposal,VoteThreshold)"
              },
              "fallback": "0x00",
              "documentation": [
                " The referendum to be tabled whenever it would be valid to table an external proposal.",
                " This happens when a referendum needs to be tabled and one of two conditions are met:",
                " - `LastTabledWasExternal` is `false`; or",
                " - `PublicProps` is empty."
              ]
            },
            {
              "name": "Blacklist",
              "modifier": "Optional",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "Hash",
                  "value": "(BlockNumber,Vec<AccountId>)",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " A record of who vetoed what. Maps proposal hash to a possible existent block number",
                " (until when it may not be resubmitted) and who vetoed it."
              ]
            },
            {
              "name": "Cancellations",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "Hash",
                  "value": "bool",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " Record of all proposals that have been subject to emergency cancellation."
              ]
            }
          ],
          "calls": [
            {
              "name": "propose",
              "args": [
                {
                  "name": "proposal",
                  "type": "Proposal"
                },
                {
                  "name": "value",
                  "type": "Compact<BalanceOf>"
                }
              ],
              "documentation": [
                " Propose a sensitive action to be taken."
              ]
            },
            {
              "name": "second",
              "args": [
                {
                  "name": "proposal",
                  "type": "Compact<PropIndex>"
                }
              ],
              "documentation": [
                " Propose a sensitive action to be taken."
              ]
            },
            {
              "name": "vote",
              "args": [
                {
                  "name": "ref_index",
                  "type": "Compact<ReferendumIndex>"
                },
                {
                  "name": "vote",
                  "type": "Vote"
                }
              ],
              "documentation": [
                " Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;",
                " otherwise it is a vote to keep the status quo."
              ]
            },
            {
              "name": "proxy_vote",
              "args": [
                {
                  "name": "ref_index",
                  "type": "Compact<ReferendumIndex>"
                },
                {
                  "name": "vote",
                  "type": "Vote"
                }
              ],
              "documentation": [
                " Vote in a referendum on behalf of a stash. If `vote.is_aye()`, the vote is to enact",
                " the proposal;  otherwise it is a vote to keep the status quo."
              ]
            },
            {
              "name": "emergency_propose",
              "args": [
                {
                  "name": "proposal",
                  "type": "Proposal"
                },
                {
                  "name": "threshold",
                  "type": "VoteThreshold"
                },
                {
                  "name": "voting_period",
                  "type": "BlockNumber"
                },
                {
                  "name": "delay",
                  "type": "BlockNumber"
                }
              ],
              "documentation": [
                " Schedule an emergency referendum.",
                "",
                " This will create a new referendum for the `proposal`, approved as long as counted votes",
                " exceed `threshold` and, if approved, enacted after the given `delay`.",
                "",
                " It may be called from either the Root or the Emergency origin."
              ]
            },
            {
              "name": "emergency_cancel",
              "args": [
                {
                  "name": "ref_index",
                  "type": "ReferendumIndex"
                }
              ],
              "documentation": [
                " Schedule an emergency cancellation of a referendum. Cannot happen twice to the same",
                " referendum."
              ]
            },
            {
              "name": "external_propose",
              "args": [
                {
                  "name": "proposal",
                  "type": "Proposal"
                }
              ],
              "documentation": [
                " Schedule a referendum to be tabled once it is legal to schedule an external",
                " referendum."
              ]
            },
            {
              "name": "external_propose_majority",
              "args": [
                {
                  "name": "proposal",
                  "type": "Proposal"
                }
              ],
              "documentation": [
                " Schedule a majority-carries referendum to be tabled next once it is legal to schedule",
                " an external referendum."
              ]
            },
            {
              "name": "veto_external",
              "args": [
                {
                  "name": "proposal_hash",
                  "type": "Hash"
                }
              ],
              "documentation": [
                " Veto and blacklist the external proposal hash."
              ]
            },
            {
              "name": "cancel_referendum",
              "args": [
                {
                  "name": "ref_index",
                  "type": "Compact<ReferendumIndex>"
                }
              ],
              "documentation": [
                " Remove a referendum."
              ]
            },
            {
              "name": "cancel_queued",
              "args": [
                {
                  "name": "when",
                  "type": "Compact<BlockNumber>"
                },
                {
                  "name": "which",
                  "type": "Compact<u32>"
                },
                {
                  "name": "what",
                  "type": "Compact<ReferendumIndex>"
                }
              ],
              "documentation": [
                " Cancel a proposal queued for enactment."
              ]
            },
            {
              "name": "set_proxy",
              "args": [
                {
                  "name": "proxy",
                  "type": "AccountId"
                }
              ],
              "documentation": [
                " Specify a proxy. Called by the stash."
              ]
            },
            {
              "name": "resign_proxy",
              "args": [],
              "documentation": [
                " Clear the proxy. Called by the proxy."
              ]
            },
            {
              "name": "remove_proxy",
              "args": [
                {
                  "name": "proxy",
                  "type": "AccountId"
                }
              ],
              "documentation": [
                " Clear the proxy. Called by the stash."
              ]
            },
            {
              "name": "delegate",
              "args": [
                {
                  "name": "to",
                  "type": "AccountId"
                },
                {
                  "name": "conviction",
                  "type": "Conviction"
                }
              ],
              "documentation": [
                " Delegate vote."
              ]
            },
            {
              "name": "undelegate",
              "args": [],
              "documentation": [
                " Undelegate vote."
              ]
            }
          ],
          "events": [
            {
              "name": "Proposed",
              "args": [
                "PropIndex",
                "Balance"
              ],
              "documentation": []
            },
            {
              "name": "Tabled",
              "args": [
                "PropIndex",
                "Balance",
                "Vec<AccountId>"
              ],
              "documentation": []
            },
            {
              "name": "ExternalTabled",
              "args": [],
              "documentation": []
            },
            {
              "name": "Started",
              "args": [
                "ReferendumIndex",
                "VoteThreshold"
              ],
              "documentation": []
            },
            {
              "name": "Passed",
              "args": [
                "ReferendumIndex"
              ],
              "documentation": []
            },
            {
              "name": "NotPassed",
              "args": [
                "ReferendumIndex"
              ],
              "documentation": []
            },
            {
              "name": "Cancelled",
              "args": [
                "ReferendumIndex"
              ],
              "documentation": []
            },
            {
              "name": "Executed",
              "args": [
                "ReferendumIndex",
                "bool"
              ],
              "documentation": []
            },
            {
              "name": "Delegated",
              "args": [
                "AccountId",
                "AccountId"
              ],
              "documentation": []
            },
            {
              "name": "Undelegated",
              "args": [
                "AccountId"
              ],
              "documentation": []
            },
            {
              "name": "Vetoed",
              "args": [
                "AccountId",
                "Hash",
                "BlockNumber"
              ],
              "documentation": []
            }
          ]
        },
        {
          "name": "council",
          "prefix": "Council",
          "storage": [
            {
              "name": "CandidacyBond",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x09000000000000000000000000000000",
              "documentation": [
                " How much should be locked up in order to submit one's candidacy."
              ]
            },
            {
              "name": "VotingBond",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " How much should be locked up in order to be able to submit votes."
              ]
            },
            {
              "name": "PresentSlashPerVoter",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x01000000000000000000000000000000",
              "documentation": [
                " The punishment, per voter, if you provide an invalid presentation."
              ]
            },
            {
              "name": "CarryCount",
              "modifier": "Default",
              "type": {
                "PlainType": "u32"
              },
              "fallback": "0x02000000",
              "documentation": [
                " How many runners-up should have their approvals persist until the next vote."
              ]
            },
            {
              "name": "PresentationDuration",
              "modifier": "Default",
              "type": {
                "PlainType": "BlockNumber"
              },
              "fallback": "0xe803000000000000",
              "documentation": [
                " How long to give each top candidate to present themselves after the vote ends."
              ]
            },
            {
              "name": "InactiveGracePeriod",
              "modifier": "Default",
              "type": {
                "PlainType": "VoteIndex"
              },
              "fallback": "0x01000000",
              "documentation": [
                " How many vote indexes need to go by after a target voter's last vote before they can be reaped if their",
                " approvals are moot."
              ]
            },
            {
              "name": "VotingPeriod",
              "modifier": "Default",
              "type": {
                "PlainType": "BlockNumber"
              },
              "fallback": "0xe803000000000000",
              "documentation": [
                " How often (in blocks) to check for new votes."
              ]
            },
            {
              "name": "TermDuration",
              "modifier": "Default",
              "type": {
                "PlainType": "BlockNumber"
              },
              "fallback": "0x0500000000000000",
              "documentation": [
                " How long each position is active for."
              ]
            },
            {
              "name": "DesiredSeats",
              "modifier": "Default",
              "type": {
                "PlainType": "u32"
              },
              "fallback": "0x00000000",
              "documentation": [
                " Number of accounts that should be sitting on the council."
              ]
            },
            {
              "name": "ActiveCouncil",
              "modifier": "Default",
              "type": {
                "PlainType": "Vec<(AccountId,BlockNumber)>"
              },
              "fallback": "0x00",
              "documentation": [
                " The current council. When there's a vote going on, this should still be used for executive",
                " matters. The block number (second element in the tuple) is the block that their position is",
                " active until (calculated by the sum of the block number when the council member was elected",
                " and their term duration)."
              ]
            },
            {
              "name": "VoteCount",
              "modifier": "Default",
              "type": {
                "PlainType": "VoteIndex"
              },
              "fallback": "0x00000000",
              "documentation": [
                " The total number of votes that have happened or are in progress."
              ]
            },
            {
              "name": "ApprovalsOf",
              "modifier": "Default",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "Vec<bool>",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " A list of votes for each voter, respecting the last cleared vote index that this voter was",
                " last active at."
              ]
            },
            {
              "name": "RegisterInfoOf",
              "modifier": "Optional",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "(VoteIndex,u32)",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " The vote index and list slot that the candidate `who` was registered or `None` if they are not",
                " currently registered."
              ]
            },
            {
              "name": "LastActiveOf",
              "modifier": "Optional",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "VoteIndex",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " The last cleared vote index that this voter was last active at."
              ]
            },
            {
              "name": "Voters",
              "modifier": "Default",
              "type": {
                "PlainType": "Vec<AccountId>"
              },
              "fallback": "0x00",
              "documentation": [
                " The present voter list."
              ]
            },
            {
              "name": "Candidates",
              "modifier": "Default",
              "type": {
                "PlainType": "Vec<AccountId>"
              },
              "fallback": "0x00",
              "documentation": [
                " The present candidate list."
              ]
            },
            {
              "name": "CandidateCount",
              "modifier": "Default",
              "type": {
                "PlainType": "u32"
              },
              "fallback": "0x00000000",
              "documentation": []
            },
            {
              "name": "NextFinalize",
              "modifier": "Optional",
              "type": {
                "PlainType": "(BlockNumber,u32,Vec<AccountId>)"
              },
              "fallback": "0x00",
              "documentation": [
                " The accounts holding the seats that will become free on the next tally."
              ]
            },
            {
              "name": "SnapshotedStakes",
              "modifier": "Default",
              "type": {
                "PlainType": "Vec<BalanceOf>"
              },
              "fallback": "0x00",
              "documentation": [
                " The stakes as they were at the point that the vote ended."
              ]
            },
            {
              "name": "Leaderboard",
              "modifier": "Optional",
              "type": {
                "PlainType": "Vec<(BalanceOf,AccountId)>"
              },
              "fallback": "0x00",
              "documentation": [
                " Get the leaderboard if we;re in the presentation phase."
              ]
            }
          ],
          "calls": [
            {
              "name": "set_approvals",
              "args": [
                {
                  "name": "votes",
                  "type": "Vec<bool>"
                },
                {
                  "name": "index",
                  "type": "Compact<VoteIndex>"
                }
              ],
              "documentation": [
                " Set candidate approvals. Approval slots stay valid as long as candidates in those slots",
                " are registered."
              ]
            },
            {
              "name": "proxy_set_approvals",
              "args": [
                {
                  "name": "votes",
                  "type": "Vec<bool>"
                },
                {
                  "name": "index",
                  "type": "Compact<VoteIndex>"
                }
              ],
              "documentation": [
                " Set candidate approvals from a proxy. Approval slots stay valid as long as candidates in those slots",
                " are registered."
              ]
            },
            {
              "name": "reap_inactive_voter",
              "args": [
                {
                  "name": "reporter_index",
                  "type": "Compact<u32>"
                },
                {
                  "name": "who",
                  "type": "Address"
                },
                {
                  "name": "who_index",
                  "type": "Compact<u32>"
                },
                {
                  "name": "assumed_vote_index",
                  "type": "Compact<VoteIndex>"
                }
              ],
              "documentation": [
                " Remove a voter. For it not to be a bond-consuming no-op, all approved candidate indices",
                " must now be either unregistered or registered to a candidate that registered the slot after",
                " the voter gave their last approval set.",
                "",
                " May be called by anyone. Returns the voter deposit to `signed`."
              ]
            },
            {
              "name": "retract_voter",
              "args": [
                {
                  "name": "index",
                  "type": "Compact<u32>"
                }
              ],
              "documentation": [
                " Remove a voter. All votes are cancelled and the voter deposit is returned."
              ]
            },
            {
              "name": "submit_candidacy",
              "args": [
                {
                  "name": "slot",
                  "type": "Compact<u32>"
                }
              ],
              "documentation": [
                " Submit oneself for candidacy.",
                "",
                " Account must have enough transferrable funds in it to pay the bond."
              ]
            },
            {
              "name": "present_winner",
              "args": [
                {
                  "name": "candidate",
                  "type": "Address"
                },
                {
                  "name": "total",
                  "type": "Compact<BalanceOf>"
                },
                {
                  "name": "index",
                  "type": "Compact<VoteIndex>"
                }
              ],
              "documentation": [
                " Claim that `signed` is one of the top Self::carry_count() + current_vote().1 candidates.",
                " Only works if the `block_number >= current_vote().0` and `< current_vote().0 + presentation_duration()``",
                " `signed` should have at least"
              ]
            },
            {
              "name": "set_desired_seats",
              "args": [
                {
                  "name": "count",
                  "type": "Compact<u32>"
                }
              ],
              "documentation": [
                " Set the desired member count; if lower than the current count, then seats will not be up",
                " election when they expire. If more, then a new vote will be started if one is not",
                " already in progress."
              ]
            },
            {
              "name": "remove_member",
              "args": [
                {
                  "name": "who",
                  "type": "Address"
                }
              ],
              "documentation": [
                " Remove a particular member from the council. This is effective immediately.",
                "",
                " Note: A tally should happen instantly (if not already in a presentation",
                " period) to fill the seat if removal means that the desired members are not met."
              ]
            },
            {
              "name": "set_presentation_duration",
              "args": [
                {
                  "name": "count",
                  "type": "Compact<BlockNumber>"
                }
              ],
              "documentation": [
                " Set the presentation duration. If there is currently a vote being presented for, will",
                " invoke `finalize_vote`."
              ]
            },
            {
              "name": "set_term_duration",
              "args": [
                {
                  "name": "count",
                  "type": "Compact<BlockNumber>"
                }
              ],
              "documentation": [
                " Set the presentation duration. If there is current a vote being presented for, will",
                " invoke `finalize_vote`."
              ]
            }
          ],
          "events": [
            {
              "name": "VoterReaped",
              "args": [
                "AccountId",
                "AccountId"
              ],
              "documentation": [
                " reaped voter, reaper"
              ]
            },
            {
              "name": "BadReaperSlashed",
              "args": [
                "AccountId"
              ],
              "documentation": [
                " slashed reaper"
              ]
            },
            {
              "name": "TallyStarted",
              "args": [
                "u32"
              ],
              "documentation": [
                " A tally (for approval votes of council seat(s)) has started."
              ]
            },
            {
              "name": "TallyFinalized",
              "args": [
                "Vec<AccountId>",
                "Vec<AccountId>"
              ],
              "documentation": [
                " A tally (for approval votes of council seat(s)) has ended (with one or more new members)."
              ]
            }
          ]
        },
        {
          "name": "council_motions",
          "prefix": "CouncilMotions",
          "storage": [
            {
              "name": "Proposals",
              "modifier": "Default",
              "type": {
                "PlainType": "Vec<Hash>"
              },
              "fallback": "0x00",
              "documentation": [
                " The hashes of the active proposals."
              ]
            },
            {
              "name": "ProposalOf",
              "modifier": "Optional",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "Hash",
                  "value": "Proposal",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " Actual proposal for a given hash, if it's current."
              ]
            },
            {
              "name": "Voting",
              "modifier": "Optional",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "Hash",
                  "value": "Votes",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " Votes on a given proposal, if it is ongoing."
              ]
            },
            {
              "name": "ProposalCount",
              "modifier": "Default",
              "type": {
                "PlainType": "u32"
              },
              "fallback": "0x00000000",
              "documentation": [
                " Proposals so far."
              ]
            }
          ],
          "calls": [
            {
              "name": "execute",
              "args": [
                {
                  "name": "proposal",
                  "type": "Proposal"
                }
              ],
              "documentation": [
                " Dispatch a proposal from a councilor using the `Member` origin.",
                "",
                " Origin must be a council member."
              ]
            },
            {
              "name": "propose",
              "args": [
                {
                  "name": "threshold",
                  "type": "Compact<MemberCount>"
                },
                {
                  "name": "proposal",
                  "type": "Proposal"
                }
              ],
              "documentation": []
            },
            {
              "name": "vote",
              "args": [
                {
                  "name": "proposal",
                  "type": "Hash"
                },
                {
                  "name": "index",
                  "type": "Compact<ProposalIndex>"
                },
                {
                  "name": "approve",
                  "type": "bool"
                }
              ],
              "documentation": []
            }
          ],
          "events": [
            {
              "name": "Proposed",
              "args": [
                "AccountId",
                "ProposalIndex",
                "Hash",
                "MemberCount"
              ],
              "documentation": [
                " A motion (given hash) has been proposed (by given account) with a threshold (given",
                " `MemberCount`)."
              ]
            },
            {
              "name": "Voted",
              "args": [
                "AccountId",
                "Hash",
                "bool",
                "MemberCount",
                "MemberCount"
              ],
              "documentation": [
                " A motion (given hash) has been voted on by given account, leaving",
                " a tally (yes votes and no votes given respectively as `MemberCount`)."
              ]
            },
            {
              "name": "Approved",
              "args": [
                "Hash"
              ],
              "documentation": [
                " A motion was approved by the required threshold."
              ]
            },
            {
              "name": "Disapproved",
              "args": [
                "Hash"
              ],
              "documentation": [
                " A motion was not approved by the required threshold."
              ]
            },
            {
              "name": "Executed",
              "args": [
                "Hash",
                "bool"
              ],
              "documentation": [
                " A motion was executed; `bool` is true if returned without error."
              ]
            },
            {
              "name": "MemberExecuted",
              "args": [
                "Hash",
                "bool"
              ],
              "documentation": [
                " A single councillor did some action; `bool` is true if returned without error."
              ]
            }
          ]
        },
        {
          "name": "finality_tracker",
          "prefix": "",
          "storage": null,
          "calls": [
            {
              "name": "final_hint",
              "args": [
                {
                  "name": "hint",
                  "type": "Compact<BlockNumber>"
                }
              ],
              "documentation": [
                " Hint that the author of this block thinks the best finalized",
                " block is the given number."
              ]
            }
          ],
          "events": null
        },
        {
          "name": "grandpa",
          "prefix": "GrandpaFinality",
          "storage": [
            {
              "name": "PendingChange",
              "modifier": "Optional",
              "type": {
                "PlainType": "StoredPendingChange"
              },
              "fallback": "0x00",
              "documentation": []
            },
            {
              "name": "NextForced",
              "modifier": "Optional",
              "type": {
                "PlainType": "BlockNumber"
              },
              "fallback": "0x00",
              "documentation": []
            }
          ],
          "calls": [
            {
              "name": "report_misbehavior",
              "args": [
                {
                  "name": "_report",
                  "type": "Bytes"
                }
              ],
              "documentation": [
                " Report some misbehavior."
              ]
            }
          ],
          "events": [
            {
              "name": "NewAuthorities",
              "args": [
                "Vec<(SessionKey,u64)>"
              ],
              "documentation": [
                " New authority set has been applied."
              ]
            }
          ]
        },
        {
          "name": "treasury",
          "prefix": "Treasury",
          "storage": [
            {
              "name": "ProposalBond",
              "modifier": "Default",
              "type": {
                "PlainType": "Permill"
              },
              "fallback": "0x00000000",
              "documentation": [
                " Fraction of a proposal's value that should be bonded in order to place the proposal.",
                " An accepted proposal gets these back. A rejected proposal does not."
              ]
            },
            {
              "name": "ProposalBondMinimum",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " Minimum amount of funds that should be placed in a deposit for making a proposal."
              ]
            },
            {
              "name": "SpendPeriod",
              "modifier": "Default",
              "type": {
                "PlainType": "BlockNumber"
              },
              "fallback": "0x0100000000000000",
              "documentation": [
                " Period between successive spends."
              ]
            },
            {
              "name": "Burn",
              "modifier": "Default",
              "type": {
                "PlainType": "Permill"
              },
              "fallback": "0x00000000",
              "documentation": [
                " Percentage of spare funds (if any) that are burnt per spend period."
              ]
            },
            {
              "name": "Pot",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " Total funds available to this module for spending."
              ]
            },
            {
              "name": "ProposalCount",
              "modifier": "Default",
              "type": {
                "PlainType": "ProposalIndex"
              },
              "fallback": "0x00000000",
              "documentation": [
                " Number of proposals that have been made."
              ]
            },
            {
              "name": "Proposals",
              "modifier": "Optional",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "ProposalIndex",
                  "value": "TreasuryProposal",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " Proposals that have been made."
              ]
            },
            {
              "name": "Approvals",
              "modifier": "Default",
              "type": {
                "PlainType": "Vec<ProposalIndex>"
              },
              "fallback": "0x00",
              "documentation": [
                " Proposal indices that have been approved but not yet awarded."
              ]
            }
          ],
          "calls": [
            {
              "name": "propose_spend",
              "args": [
                {
                  "name": "value",
                  "type": "Compact<BalanceOf>"
                },
                {
                  "name": "beneficiary",
                  "type": "Address"
                }
              ],
              "documentation": [
                " Put forward a suggestion for spending. A deposit proportional to the value",
                " is reserved and slashed if the proposal is rejected. It is returned once the",
                " proposal is awarded."
              ]
            },
            {
              "name": "set_pot",
              "args": [
                {
                  "name": "new_pot",
                  "type": "Compact<BalanceOf>"
                }
              ],
              "documentation": [
                " Set the balance of funds available to spend."
              ]
            },
            {
              "name": "configure",
              "args": [
                {
                  "name": "proposal_bond",
                  "type": "Compact<Permill>"
                },
                {
                  "name": "proposal_bond_minimum",
                  "type": "Compact<BalanceOf>"
                },
                {
                  "name": "spend_period",
                  "type": "Compact<BlockNumber>"
                },
                {
                  "name": "burn",
                  "type": "Compact<Permill>"
                }
              ],
              "documentation": [
                " (Re-)configure this module."
              ]
            },
            {
              "name": "reject_proposal",
              "args": [
                {
                  "name": "proposal_id",
                  "type": "Compact<ProposalIndex>"
                }
              ],
              "documentation": [
                " Reject a proposed spend. The original deposit will be slashed."
              ]
            },
            {
              "name": "approve_proposal",
              "args": [
                {
                  "name": "proposal_id",
                  "type": "Compact<ProposalIndex>"
                }
              ],
              "documentation": [
                " Approve a proposal. At a later time, the proposal will be allocated to the beneficiary",
                " and the original deposit will be returned."
              ]
            }
          ],
          "events": [
            {
              "name": "Proposed",
              "args": [
                "ProposalIndex"
              ],
              "documentation": [
                " New proposal."
              ]
            },
            {
              "name": "Spending",
              "args": [
                "Balance"
              ],
              "documentation": [
                " We have ended a spend period and will now allocate funds."
              ]
            },
            {
              "name": "Awarded",
              "args": [
                "ProposalIndex",
                "Balance",
                "AccountId"
              ],
              "documentation": [
                " Some funds have been allocated."
              ]
            },
            {
              "name": "Burnt",
              "args": [
                "Balance"
              ],
              "documentation": [
                " Some of our funds have been burnt."
              ]
            },
            {
              "name": "Rollover",
              "args": [
                "Balance"
              ],
              "documentation": [
                " Spending has finished; this is the amount that rolls over until next spend."
              ]
            }
          ]
        },
        {
          "name": "contract",
          "prefix": "Contract",
          "storage": [
            {
              "name": "SignedClaimHandicap",
              "modifier": "Default",
              "type": {
                "PlainType": "BlockNumber"
              },
              "fallback": "0x0000000000000000",
              "documentation": [
                " Number of block delay an extrinsic claim surcharge has.",
                "",
                " When claim surchage is called by an extrinsic the rent is checked",
                " for current_block - delay"
              ]
            },
            {
              "name": "TombstoneDeposit",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " The minimum amount required to generate a tombstone."
              ]
            },
            {
              "name": "StorageSizeOffset",
              "modifier": "Default",
              "type": {
                "PlainType": "u32"
              },
              "fallback": "0x00000000",
              "documentation": [
                " Size of a contract at the time of creation. This is a simple way to ensure",
                " that empty contracts eventually gets deleted."
              ]
            },
            {
              "name": "RentByteFee",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " Price of a byte of storage per one block interval. Should be greater than 0."
              ]
            },
            {
              "name": "RentDepositOffset",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " The amount of funds a contract should deposit in order to offset",
                " the cost of one byte.",
                "",
                " Let's suppose the deposit is 1,000 BU (balance units)/byte and the rent is 1 BU/byte/day,",
                " then a contract with 1,000,000 BU that uses 1,000 bytes of storage would pay no rent.",
                " But if the balance reduced to 500,000 BU and the storage stayed the same at 1,000,",
                " then it would pay 500 BU/day."
              ]
            },
            {
              "name": "SurchargeReward",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " Reward that is received by the party whose touch has led",
                " to removal of a contract."
              ]
            },
            {
              "name": "TransferFee",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " The fee required to make a transfer."
              ]
            },
            {
              "name": "CreationFee",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " The fee required to create an account."
              ]
            },
            {
              "name": "TransactionBaseFee",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " The fee to be paid for making a transaction; the base."
              ]
            },
            {
              "name": "TransactionByteFee",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x00000000000000000000000000000000",
              "documentation": [
                " The fee to be paid for making a transaction; the per-byte portion."
              ]
            },
            {
              "name": "ContractFee",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x15000000000000000000000000000000",
              "documentation": [
                " The fee required to create a contract instance."
              ]
            },
            {
              "name": "CallBaseFee",
              "modifier": "Default",
              "type": {
                "PlainType": "Gas"
              },
              "fallback": "0x8700000000000000",
              "documentation": [
                " The base fee charged for calling into a contract."
              ]
            },
            {
              "name": "CreateBaseFee",
              "modifier": "Default",
              "type": {
                "PlainType": "Gas"
              },
              "fallback": "0xaf00000000000000",
              "documentation": [
                " The base fee charged for creating a contract."
              ]
            },
            {
              "name": "GasPrice",
              "modifier": "Default",
              "type": {
                "PlainType": "BalanceOf"
              },
              "fallback": "0x01000000000000000000000000000000",
              "documentation": [
                " The price of one unit of gas."
              ]
            },
            {
              "name": "MaxDepth",
              "modifier": "Default",
              "type": {
                "PlainType": "u32"
              },
              "fallback": "0x64000000",
              "documentation": [
                " The maximum nesting level of a call/create stack."
              ]
            },
            {
              "name": "BlockGasLimit",
              "modifier": "Default",
              "type": {
                "PlainType": "Gas"
              },
              "fallback": "0x8096980000000000",
              "documentation": [
                " The maximum amount of gas that could be expended per block."
              ]
            },
            {
              "name": "GasSpent",
              "modifier": "Default",
              "type": {
                "PlainType": "Gas"
              },
              "fallback": "0x0000000000000000",
              "documentation": [
                " Gas spent so far in this block."
              ]
            },
            {
              "name": "CurrentSchedule",
              "modifier": "Default",
              "type": {
                "PlainType": "Schedule"
              },
              "fallback": "0x000000000100000000000000010000000000000001000000000000000100000000000000010000000000000001000000000000000100000000000000010000000000000001000000000000000400000000000100100000000020000000",
              "documentation": [
                " Current cost schedule for contracts."
              ]
            },
            {
              "name": "PristineCode",
              "modifier": "Optional",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "CodeHash",
                  "value": "Bytes",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " A mapping from an original code hash to the original code, untouched by instrumentation."
              ]
            },
            {
              "name": "CodeStorage",
              "modifier": "Optional",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "CodeHash",
                  "value": "PrefabWasmModule",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " A mapping between an original code hash and instrumented wasm code, ready for execution."
              ]
            },
            {
              "name": "AccountCounter",
              "modifier": "Default",
              "type": {
                "PlainType": "u64"
              },
              "fallback": "0x0000000000000000",
              "documentation": [
                " The subtrie counter."
              ]
            },
            {
              "name": "ContractInfoOf",
              "modifier": "Optional",
              "type": {
                "MapType": {
                  "hasher": "Blake2_256",
                  "key": "AccountId",
                  "value": "ContractInfo",
                  "isLinked": false
                }
              },
              "fallback": "0x00",
              "documentation": [
                " The code associated with a given account."
              ]
            }
          ],
          "calls": [
            {
              "name": "update_schedule",
              "args": [
                {
                  "name": "schedule",
                  "type": "Schedule"
                }
              ],
              "documentation": [
                " Updates the schedule for metering contracts.",
                "",
                " The schedule must have a greater version than the stored schedule."
              ]
            },
            {
              "name": "put_code",
              "args": [
                {
                  "name": "gas_limit",
                  "type": "Compact<Gas>"
                },
                {
                  "name": "code",
                  "type": "Bytes"
                }
              ],
              "documentation": [
                " Stores the given binary Wasm code into the chain's storage and returns its `codehash`.",
                " You can instantiate contracts only with stored code."
              ]
            },
            {
              "name": "call",
              "args": [
                {
                  "name": "dest",
                  "type": "Address"
                },
                {
                  "name": "value",
                  "type": "Compact<BalanceOf>"
                },
                {
                  "name": "gas_limit",
                  "type": "Compact<Gas>"
                },
                {
                  "name": "data",
                  "type": "Bytes"
                }
              ],
              "documentation": [
                " Makes a call to an account, optionally transferring some balance.",
                "",
                " * If the account is a smart-contract account, the associated code will be",
                " executed and any value will be transferred.",
                " * If the account is a regular account, any value will be transferred.",
                " * If no account exists and the call value is not less than `existential_deposit`,",
                " a regular account will be created and any value will be transferred."
              ]
            },
            {
              "name": "create",
              "args": [
                {
                  "name": "endowment",
                  "type": "Compact<BalanceOf>"
                },
                {
                  "name": "gas_limit",
                  "type": "Compact<Gas>"
                },
                {
                  "name": "code_hash",
                  "type": "CodeHash"
                },
                {
                  "name": "data",
                  "type": "Bytes"
                }
              ],
              "documentation": [
                " Creates a new contract from the `codehash` generated by `put_code`, optionally transferring some balance.",
                "",
                " Creation is executed as follows:",
                "",
                " - The destination address is computed based on the sender and hash of the code.",
                " - The smart-contract account is created at the computed address.",
                " - The `ctor_code` is executed in the context of the newly-created account. Buffer returned",
                "   after the execution is saved as the `code` of the account. That code will be invoked",
                "   upon any call received by this account.",
                " - The contract is initialized."
              ]
            },
            {
              "name": "claim_surcharge",
              "args": [
                {
                  "name": "dest",
                  "type": "AccountId"
                },
                {
                  "name": "aux_sender",
                  "type": "Option<AccountId>"
                }
              ],
              "documentation": [
                " Allows block producers to claim a small reward for evicting a contract. If a block producer",
                " fails to do so, a regular users will be allowed to claim the reward.",
                "",
                " If contract is not evicted as a result of this call, no actions are taken and",
                " the sender is not eligible for the reward."
              ]
            },
            {
              "name": "restore_to",
              "args": [
                {
                  "name": "dest",
                  "type": "AccountId"
                },
                {
                  "name": "code_hash",
                  "type": "CodeHash"
                },
                {
                  "name": "rent_allowance",
                  "type": "BalanceOf"
                },
                {
                  "name": "delta",
                  "type": "Vec<ContractStorageKey>"
                }
              ],
              "documentation": [
                " Allows a contract to restore a tombstone by giving its storage.",
                "",
                " The contract that wants to restore (i.e. origin of the call, or `msg.sender` in Solidity terms) will compute a",
                " tombstone with its storage and the given code_hash. If the computed tombstone",
                " match the destination one, the destination contract is restored with the rent_allowance` specified,",
                " while the origin sends all its funds to the destination and is removed."
              ]
            }
          ],
          "events": [
            {
              "name": "Transfer",
              "args": [
                "AccountId",
                "AccountId",
                "Balance"
              ],
              "documentation": [
                " Transfer happened `from` to `to` with given `value` as part of a `call` or `create`."
              ]
            },
            {
              "name": "Instantiated",
              "args": [
                "AccountId",
                "AccountId"
              ],
              "documentation": [
                " Contract deployed by address at the specified address."
              ]
            },
            {
              "name": "CodeStored",
              "args": [
                "Hash"
              ],
              "documentation": [
                " Code with the specified hash has been stored."
              ]
            },
            {
              "name": "ScheduleUpdated",
              "args": [
                "u32"
              ],
              "documentation": [
                " Triggered when the current schedule is updated."
              ]
            },
            {
              "name": "Dispatched",
              "args": [
                "AccountId",
                "bool"
              ],
              "documentation": [
                " A call was dispatched from the given account. The bool signals whether it was",
                " successful execution or not."
              ]
            },
            {
              "name": "Contract",
              "args": [
                "AccountId",
                "Bytes"
              ],
              "documentation": [
                " An event from contract of account."
              ]
            }
          ]
        },
        {
          "name": "sudo",
          "prefix": "Sudo",
          "storage": [
            {
              "name": "Key",
              "modifier": "Default",
              "type": {
                "PlainType": "AccountId"
              },
              "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
              "documentation": [
                " The `AccountId` of the sudo key."
              ]
            }
          ],
          "calls": [
            {
              "name": "sudo",
              "args": [
                {
                  "name": "proposal",
                  "type": "Proposal"
                }
              ],
              "documentation": [
                " Authenticates the sudo key and dispatches a function call with `Root` origin.",
                "",
                " The dispatch origin for this call must be _Signed_."
              ]
            },
            {
              "name": "set_key",
              "args": [
                {
                  "name": "new",
                  "type": "Address"
                }
              ],
              "documentation": [
                " Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.",
                "",
                " The dispatch origin for this call must be _Signed_."
              ]
            }
          ],
          "events": [
            {
              "name": "Sudid",
              "args": [
                "bool"
              ],
              "documentation": [
                " A sudo just took place."
              ]
            },
            {
              "name": "KeyChanged",
              "args": [
                "AccountId"
              ],
              "documentation": [
                " The sudoer just switched identity; the old key is supplied."
              ]
            }
          ]
        }
      ]
    }
  }
}
