{
  "magicNumber": 1635018093,
  "metadata": {
    "V7": {
      "modules": [
        {
          "name": "System",
          "storage": {
            "prefix": "System",
            "items": [
              {
                "name": "AccountNonce",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "AccountId",
                    "value": "Index",
                    "linked": false
                  }
                },
                "fallback": "0x00000000",
                "documentation": [
                  " Extrinsics nonce for accounts."
                ]
              },
              {
                "name": "ExtrinsicCount",
                "modifier": "optional",
                "type": {
                  "Plain": "u32"
                },
                "fallback": "0x00",
                "documentation": [
                  " Total extrinsics count for the current block."
                ]
              },
              {
                "name": "AllExtrinsicsWeight",
                "modifier": "optional",
                "type": {
                  "Plain": "Weight"
                },
                "fallback": "0x00",
                "documentation": [
                  " Total weight for all extrinsics put together, for the current block."
                ]
              },
              {
                "name": "AllExtrinsicsLen",
                "modifier": "optional",
                "type": {
                  "Plain": "u32"
                },
                "fallback": "0x00",
                "documentation": [
                  " Total length (in bytes) for all extrinsics put together, for the current block."
                ]
              },
              {
                "name": "NextWeightMultiplier",
                "modifier": "default",
                "type": {
                  "Plain": "WeightMultiplier"
                },
                "fallback": "0x0000000000000000",
                "documentation": [
                  " The next weight multiplier. This should be updated at the end of each block based on the",
                  " saturation level (weight)."
                ]
              },
              {
                "name": "BlockHash",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "BlockNumber",
                    "value": "Hash",
                    "linked": false
                  }
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "documentation": [
                  " Map of block numbers to block hashes."
                ]
              },
              {
                "name": "ExtrinsicData",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "u32",
                    "value": "Bytes",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Extrinsics data for the current block (maps an extrinsic's index to its data)."
                ]
              },
              {
                "name": "RandomMaterial",
                "modifier": "default",
                "type": {
                  "Plain": "(i8,Vec<Hash>)"
                },
                "fallback": "0x0000",
                "documentation": [
                  " Series of block headers from the last 81 blocks that acts as random seed material. This is arranged as a",
                  " ring buffer with the `i8` prefix being the index into the `Vec` of the oldest hash."
                ]
              },
              {
                "name": "Number",
                "modifier": "default",
                "type": {
                  "Plain": "BlockNumber"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " The current block number being processed. Set by `execute_block`."
                ]
              },
              {
                "name": "ParentHash",
                "modifier": "default",
                "type": {
                  "Plain": "Hash"
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "documentation": [
                  " Hash of the previous block."
                ]
              },
              {
                "name": "ExtrinsicsRoot",
                "modifier": "default",
                "type": {
                  "Plain": "Hash"
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "documentation": [
                  " Extrinsics root of the current block, also part of the block header."
                ]
              },
              {
                "name": "Digest",
                "modifier": "default",
                "type": {
                  "Plain": "DigestOf"
                },
                "fallback": "0x00",
                "documentation": [
                  " Digest of the current block, also part of the block header."
                ]
              },
              {
                "name": "Events",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<EventRecord>"
                },
                "fallback": "0x00",
                "documentation": [
                  " Events deposited for the current block."
                ]
              },
              {
                "name": "EventCount",
                "modifier": "default",
                "type": {
                  "Plain": "EventIndex"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " The number of events in the `Events<T>` list."
                ]
              },
              {
                "name": "EventTopics",
                "modifier": "default",
                "type": {
                  "DoubleMap": {
                    "hasher": "blake2256",
                    "key1": "Null",
                    "key2": "Hash",
                    "value": "Vec<(BlockNumber,EventIndex)>",
                    "key2Hasher": "blake2256"
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Mapping between a topic (represented by T::Hash) and a vector of indexes",
                  " of events in the `<Events<T>>` list.",
                  "",
                  " The first key serves no purpose. This field is declared as double_map just",
                  " for convenience of using `remove_prefix`.",
                  "",
                  " All topic vectors have deterministic storage locations depending on the topic. This",
                  " allows light-clients to leverage the changes trie storage tracking mechanism and",
                  " in case of changes fetch the list of events of interest.",
                  "",
                  " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just",
                  " the `EventIndex` then in case if the topic has the same contents on the next block",
                  " no notification will be triggered thus the event might be lost."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "fill_block",
              "args": [],
              "documentation": [
                " A big dispatch that will disallow any other transaction to be included."
              ]
            },
            {
              "name": "remark",
              "args": [
                {
                  "name": "_remark",
                  "type": "Bytes"
                }
              ],
              "documentation": [
                " Make some on-chain remark."
              ]
            },
            {
              "name": "set_heap_pages",
              "args": [
                {
                  "name": "pages",
                  "type": "u64"
                }
              ],
              "documentation": [
                " Set the number of pages in the WebAssembly environment's heap."
              ]
            },
            {
              "name": "set_code",
              "args": [
                {
                  "name": "new",
                  "type": "Bytes"
                }
              ],
              "documentation": [
                " Set the new code."
              ]
            },
            {
              "name": "set_storage",
              "args": [
                {
                  "name": "items",
                  "type": "Vec<KeyValue>"
                }
              ],
              "documentation": [
                " Set some items of storage."
              ]
            },
            {
              "name": "kill_storage",
              "args": [
                {
                  "name": "keys",
                  "type": "Vec<Key>"
                }
              ],
              "documentation": [
                " Kill some items from storage."
              ]
            }
          ],
          "events": [
            {
              "name": "ExtrinsicSuccess",
              "args": [],
              "documentation": [
                " An extrinsic completed successfully."
              ]
            },
            {
              "name": "ExtrinsicFailed",
              "args": [
                "DispatchError"
              ],
              "documentation": [
                " An extrinsic failed."
              ]
            }
          ],
          "constants": []
        },
        {
          "name": "Babe",
          "storage": {
            "prefix": "Babe",
            "items": [
              {
                "name": "EpochIndex",
                "modifier": "default",
                "type": {
                  "Plain": "u64"
                },
                "fallback": "0x0000000000000000",
                "documentation": [
                  " Current epoch index."
                ]
              },
              {
                "name": "Authorities",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<(AuthorityId,BabeAuthorityWeight)>"
                },
                "fallback": "0x00",
                "documentation": [
                  " Current epoch authorities."
                ]
              },
              {
                "name": "GenesisSlot",
                "modifier": "default",
                "type": {
                  "Plain": "u64"
                },
                "fallback": "0x0000000000000000",
                "documentation": [
                  " The slot at which the first epoch actually started. This is 0",
                  " until the first block of the chain."
                ]
              },
              {
                "name": "CurrentSlot",
                "modifier": "default",
                "type": {
                  "Plain": "u64"
                },
                "fallback": "0x0000000000000000",
                "documentation": [
                  " Current slot number."
                ]
              },
              {
                "name": "Randomness",
                "modifier": "default",
                "type": {
                  "Plain": "[u8;32]"
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "documentation": [
                  " The epoch randomness for the *current* epoch.",
                  "",
                  " # Security",
                  "",
                  " This MUST NOT be used for gambling, as it can be influenced by a",
                  " malicious validator in the short term. It MAY be used in many",
                  " cryptographic protocols, however, so long as one remembers that this",
                  " (like everything else on-chain) it is public. For example, it can be",
                  " used where a number is needed that cannot have been chosen by an",
                  " adversary, for purposes such as public-coin zero-knowledge proofs."
                ]
              },
              {
                "name": "NextRandomness",
                "modifier": "default",
                "type": {
                  "Plain": "[u8;32]"
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "documentation": [
                  " Next epoch randomness."
                ]
              },
              {
                "name": "SegmentIndex",
                "modifier": "default",
                "type": {
                  "Plain": "u32"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " Randomness under construction.",
                  "",
                  " We make a tradeoff between storage accesses and list length.",
                  " We store the under-construction randomness in segments of up to",
                  " `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.",
                  "",
                  " Once a segment reaches this length, we begin the next one.",
                  " We reset all segments and return to `0` at the beginning of every",
                  " epoch."
                ]
              },
              {
                "name": "UnderConstruction",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "u32",
                    "value": "Vec<[u8;32]>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": []
              },
              {
                "name": "Initialized",
                "modifier": "optional",
                "type": {
                  "Plain": "MaybeVrf"
                },
                "fallback": "0x00",
                "documentation": [
                  " Temporary value (cleared at block finalization) which is `Some`",
                  " if per-block initialization has already been called for current block."
                ]
              }
            ]
          },
          "calls": [],
          "events": null,
          "constants": [
            {
              "name": "EpochDuration",
              "type": "u64",
              "value": "0x6009000000000000",
              "documentation": [
                " The number of **slots** that an epoch takes. We couple sessions to",
                " epochs, i.e. we start a new session once the new epoch begins."
              ]
            },
            {
              "name": "ExpectedBlockTime",
              "type": "Moment",
              "value": "0x7017000000000000",
              "documentation": [
                " The expected average block time at which BABE should be creating",
                " blocks. Since BABE is probabilistic it is not trivial to figure out",
                " what the expected average block time should be based on the slot",
                " duration and the security parameter `c` (where `1 - c` represents",
                " the probability of a slot being empty)."
              ]
            }
          ]
        },
        {
          "name": "Timestamp",
          "storage": {
            "prefix": "Timestamp",
            "items": [
              {
                "name": "Now",
                "modifier": "default",
                "type": {
                  "Plain": "Moment"
                },
                "fallback": "0x0000000000000000",
                "documentation": [
                  " Current time for the current block."
                ]
              },
              {
                "name": "DidUpdate",
                "modifier": "default",
                "type": {
                  "Plain": "bool"
                },
                "fallback": "0x00",
                "documentation": [
                  " Did the timestamp get updated in this block?"
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "set",
              "args": [
                {
                  "name": "now",
                  "type": "Compact<Moment>"
                }
              ],
              "documentation": [
                " Set the current time.",
                "",
                " This call should be invoked exactly once per block. It will panic at the finalization",
                " phase, if this call hasn't been invoked by that time.",
                "",
                " The timestamp should be greater than the previous one by the amount specified by",
                " `MinimumPeriod`.",
                "",
                " The dispatch origin for this call must be `Inherent`."
              ]
            }
          ],
          "events": null,
          "constants": [
            {
              "name": "MinimumPeriod",
              "type": "Moment",
              "value": "0xb80b000000000000",
              "documentation": [
                " The minimum period between blocks. Beware that this is different to the *expected* period",
                " that the block production apparatus provides. Your chosen consensus system will generally",
                " work with this to determine a sensible block time. e.g. For Aura, it will be double this",
                " period on default settings."
              ]
            }
          ]
        },
        {
          "name": "Indices",
          "storage": {
            "prefix": "Indices",
            "items": [
              {
                "name": "NextEnumSet",
                "modifier": "default",
                "type": {
                  "Plain": "AccountIndex"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " The next free enumeration set."
                ]
              },
              {
                "name": "EnumSet",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "AccountIndex",
                    "value": "Vec<AccountId>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " The enumeration sets."
                ]
              }
            ]
          },
          "calls": [],
          "events": [
            {
              "name": "NewAccountIndex",
              "args": [
                "AccountId",
                "AccountIndex"
              ],
              "documentation": [
                " A new account index was assigned.",
                "",
                " This event is not triggered when an existing index is reassigned",
                " to another `AccountId`."
              ]
            }
          ],
          "constants": []
        },
        {
          "name": "Balances",
          "storage": {
            "prefix": "Balances",
            "items": [
              {
                "name": "TotalIssuance",
                "modifier": "default",
                "type": {
                  "Plain": "Balance"
                },
                "fallback": "0x00000000000000000000000000000000",
                "documentation": [
                  " The total units issued in the system."
                ]
              },
              {
                "name": "Vesting",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "AccountId",
                    "value": "VestingSchedule",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Information regarding the vesting of a given account."
                ]
              },
              {
                "name": "FreeBalance",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "AccountId",
                    "value": "Balance",
                    "linked": false
                  }
                },
                "fallback": "0x00000000000000000000000000000000",
                "documentation": [
                  " The 'free' balance of a given account.",
                  "",
                  " This is the only balance that matters in terms of most operations on tokens. It",
                  " alone is used to determine the balance when in the contract execution environment. When this",
                  " balance falls below the value of `ExistentialDeposit`, then the 'current account' is",
                  " deleted: specifically `FreeBalance`. Further, the `OnFreeBalanceZero` callback",
                  " is invoked, giving a chance to external modules to clean up data associated with",
                  " the deleted account.",
                  "",
                  " `system::AccountNonce` is also deleted if `ReservedBalance` is also zero (it also gets",
                  " collapsed to zero if it ever becomes less than `ExistentialDeposit`."
                ]
              },
              {
                "name": "ReservedBalance",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "AccountId",
                    "value": "Balance",
                    "linked": false
                  }
                },
                "fallback": "0x00000000000000000000000000000000",
                "documentation": [
                  " The amount of the balance of a given account that is externally reserved; this can still get",
                  " slashed, but gets slashed last of all.",
                  "",
                  " This balance is a 'reserve' balance that other subsystems use in order to set aside tokens",
                  " that are still 'owned' by the account holder, but which are suspendable.",
                  "",
                  " When this balance falls below the value of `ExistentialDeposit`, then this 'reserve account'",
                  " is deleted: specifically, `ReservedBalance`.",
                  "",
                  " `system::AccountNonce` is also deleted if `FreeBalance` is also zero (it also gets",
                  " collapsed to zero if it ever becomes less than `ExistentialDeposit`.)"
                ]
              },
              {
                "name": "Locks",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "AccountId",
                    "value": "Vec<BalanceLock>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Any liquidity locks on some account balances."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "transfer",
              "args": [
                {
                  "name": "dest",
                  "type": "Address"
                },
                {
                  "name": "value",
                  "type": "Compact<Balance>"
                }
              ],
              "documentation": [
                " Transfer some liquid free balance to another account.",
                "",
                " `transfer` will set the `FreeBalance` of the sender and receiver.",
                " It will decrease the total issuance of the system by the `TransferFee`.",
                " If the sender's account is below the existential deposit as a result",
                " of the transfer, the account will be reaped.",
                "",
                " The dispatch origin for this call must be `Signed` by the transactor.",
                "",
                " # <weight>",
                " - Dependent on arguments but not critical, given proper implementations for",
                "   input config types. See related functions below.",
                " - It contains a limited number of reads and writes internally and no complex computation.",
                "",
                " Related functions:",
                "",
                "   - `ensure_can_withdraw` is always called internally but has a bounded complexity.",
                "   - Transferring balances to accounts that did not exist before will cause",
                "      `T::OnNewAccount::on_new_account` to be called.",
                "   - Removing enough funds from an account will trigger",
                "     `T::DustRemoval::on_unbalanced` and `T::OnFreeBalanceZero::on_free_balance_zero`.",
                "",
                " # </weight>"
              ]
            },
            {
              "name": "set_balance",
              "args": [
                {
                  "name": "who",
                  "type": "Address"
                },
                {
                  "name": "new_free",
                  "type": "Compact<Balance>"
                },
                {
                  "name": "new_reserved",
                  "type": "Compact<Balance>"
                }
              ],
              "documentation": [
                " Set the balances of a given account.",
                "",
                " This will alter `FreeBalance` and `ReservedBalance` in storage. it will",
                " also decrease the total issuance of the system (`TotalIssuance`).",
                " If the new free or reserved balance is below the existential deposit,",
                " it will reset the account nonce (`system::AccountNonce`).",
                "",
                " The dispatch origin for this call is `root`.",
                "",
                " # <weight>",
                " - Independent of the arguments.",
                " - Contains a limited number of reads and writes.",
                " # </weight>"
              ]
            },
            {
              "name": "force_transfer",
              "args": [
                {
                  "name": "source",
                  "type": "Address"
                },
                {
                  "name": "dest",
                  "type": "Address"
                },
                {
                  "name": "value",
                  "type": "Compact<Balance>"
                }
              ],
              "documentation": [
                " Exactly as `transfer`, except the origin must be root and the source account may be",
                " specified."
              ]
            }
          ],
          "events": [
            {
              "name": "NewAccount",
              "args": [
                "AccountId",
                "Balance"
              ],
              "documentation": [
                " A new account was created."
              ]
            },
            {
              "name": "ReapedAccount",
              "args": [
                "AccountId"
              ],
              "documentation": [
                " An account was reaped."
              ]
            },
            {
              "name": "Transfer",
              "args": [
                "AccountId",
                "AccountId",
                "Balance",
                "Balance"
              ],
              "documentation": [
                " Transfer succeeded (from, to, value, fees)."
              ]
            }
          ],
          "constants": [
            {
              "name": "ExistentialDeposit",
              "type": "Balance",
              "value": "0x00ca9a3b000000000000000000000000",
              "documentation": [
                " The minimum amount required to keep an account open."
              ]
            },
            {
              "name": "TransferFee",
              "type": "Balance",
              "value": "0x00e1f505000000000000000000000000",
              "documentation": [
                " The fee required to make a transfer."
              ]
            },
            {
              "name": "CreationFee",
              "type": "Balance",
              "value": "0x00e1f505000000000000000000000000",
              "documentation": [
                " The fee required to create an account."
              ]
            },
            {
              "name": "TransactionBaseFee",
              "type": "Balance",
              "value": "0x00e1f505000000000000000000000000",
              "documentation": [
                " The fee to be paid for making a transaction; the base."
              ]
            },
            {
              "name": "TransactionByteFee",
              "type": "Balance",
              "value": "0x40420f00000000000000000000000000",
              "documentation": [
                " The fee to be paid for making a transaction; the per-byte portion."
              ]
            }
          ]
        },
        {
          "name": "Authorship",
          "storage": {
            "prefix": "Authorship",
            "items": [
              {
                "name": "Uncles",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<UncleEntryItem>"
                },
                "fallback": "0x00",
                "documentation": [
                  " Uncles"
                ]
              },
              {
                "name": "Author",
                "modifier": "optional",
                "type": {
                  "Plain": "AccountId"
                },
                "fallback": "0x00",
                "documentation": [
                  " Author of current block."
                ]
              },
              {
                "name": "DidSetUncles",
                "modifier": "default",
                "type": {
                  "Plain": "bool"
                },
                "fallback": "0x00",
                "documentation": [
                  " Whether uncles were already set in this block."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "set_uncles",
              "args": [
                {
                  "name": "new_uncles",
                  "type": "Vec<Header>"
                }
              ],
              "documentation": [
                " Provide a set of uncles."
              ]
            }
          ],
          "events": null,
          "constants": []
        },
        {
          "name": "Staking",
          "storage": {
            "prefix": "Staking",
            "items": [
              {
                "name": "ValidatorCount",
                "modifier": "default",
                "type": {
                  "Plain": "u32"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " The ideal number of staking participants."
                ]
              },
              {
                "name": "MinimumValidatorCount",
                "modifier": "default",
                "type": {
                  "Plain": "u32"
                },
                "fallback": "0x04000000",
                "documentation": [
                  " Minimum number of staking participants before emergency conditions are imposed."
                ]
              },
              {
                "name": "Invulnerables",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<AccountId>"
                },
                "fallback": "0x00",
                "documentation": [
                  " Any validators that may never be slashed or forcibly kicked. It's a Vec since they're",
                  " easy to initialize and the performance hit is minimal (we expect no more than four",
                  " invulnerables) and restricted to testnets."
                ]
              },
              {
                "name": "Bonded",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "AccountId",
                    "value": "AccountId",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Map from all locked \"stash\" accounts to the controller account."
                ]
              },
              {
                "name": "Ledger",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "AccountId",
                    "value": "StakingLedger",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Map from all (unlocked) \"controller\" accounts to the info regarding the staking."
                ]
              },
              {
                "name": "Payee",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "AccountId",
                    "value": "RewardDestination",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Where the reward payment should be made. Keyed by stash."
                ]
              },
              {
                "name": "Validators",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "AccountId",
                    "value": "ValidatorPrefs",
                    "linked": true
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " The map from (wannabe) validator stash key to the preferences of that validator."
                ]
              },
              {
                "name": "Nominators",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "AccountId",
                    "value": "Vec<AccountId>",
                    "linked": true
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " The map from nominator stash key to the set of stash keys of all validators to nominate."
                ]
              },
              {
                "name": "Stakers",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "AccountId",
                    "value": "Exposure",
                    "linked": false
                  }
                },
                "fallback": "0x000000",
                "documentation": [
                  " Nominators for a particular account that is in action right now. You can't iterate",
                  " through validators here, but you can find them in the Session module.",
                  "",
                  " This is keyed by the stash account."
                ]
              },
              {
                "name": "CurrentElected",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<AccountId>"
                },
                "fallback": "0x00",
                "documentation": [
                  " The currently elected validator set keyed by stash account ID."
                ]
              },
              {
                "name": "CurrentEra",
                "modifier": "default",
                "type": {
                  "Plain": "EraIndex"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " The current era index."
                ]
              },
              {
                "name": "CurrentEraStart",
                "modifier": "default",
                "type": {
                  "Plain": "MomentOf"
                },
                "fallback": "0x0000000000000000",
                "documentation": [
                  " The start of the current era."
                ]
              },
              {
                "name": "CurrentEraStartSessionIndex",
                "modifier": "default",
                "type": {
                  "Plain": "SessionIndex"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " The session index at which the current era started."
                ]
              },
              {
                "name": "CurrentEraPointsEarned",
                "modifier": "default",
                "type": {
                  "Plain": "EraPoints"
                },
                "fallback": "0x0000000000",
                "documentation": [
                  " Rewards for the current era. Using indices of current elected set."
                ]
              },
              {
                "name": "SlotStake",
                "modifier": "default",
                "type": {
                  "Plain": "BalanceOf"
                },
                "fallback": "0x00000000000000000000000000000000",
                "documentation": [
                  " The amount of balance actively at stake for each validator slot, currently.",
                  "",
                  " This is used to derive rewards and punishments."
                ]
              },
              {
                "name": "ForceEra",
                "modifier": "default",
                "type": {
                  "Plain": "Forcing"
                },
                "fallback": "0x00",
                "documentation": [
                  " True if the next session change will be a new era regardless of index."
                ]
              },
              {
                "name": "SlashRewardFraction",
                "modifier": "default",
                "type": {
                  "Plain": "Perbill"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " The percentage of the slash that is distributed to reporters.",
                  "",
                  " The rest of the slashed value is handled by the `Slash`."
                ]
              },
              {
                "name": "BondedEras",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<(EraIndex,SessionIndex)>"
                },
                "fallback": "0x00",
                "documentation": [
                  " A mapping from still-bonded eras to the first session index of that era."
                ]
              },
              {
                "name": "EraSlashJournal",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "EraIndex",
                    "value": "Vec<SlashJournalEntry>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " All slashes that have occurred in a given era."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "bond",
              "args": [
                {
                  "name": "controller",
                  "type": "Address"
                },
                {
                  "name": "value",
                  "type": "Compact<BalanceOf>"
                },
                {
                  "name": "payee",
                  "type": "RewardDestination"
                }
              ],
              "documentation": [
                " Take the origin account as a stash and lock up `value` of its balance. `controller` will",
                " be the account that controls it.",
                "",
                " `value` must be more than the `minimum_balance` specified by `T::Currency`.",
                "",
                " The dispatch origin for this call must be _Signed_ by the stash account.",
                "",
                " # <weight>",
                " - Independent of the arguments. Moderate complexity.",
                " - O(1).",
                " - Three extra DB entries.",
                "",
                " NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned unless",
                " the `origin` falls below _existential deposit_ and gets removed as dust.",
                " # </weight>"
              ]
            },
            {
              "name": "bond_extra",
              "args": [
                {
                  "name": "max_additional",
                  "type": "Compact<BalanceOf>"
                }
              ],
              "documentation": [
                " Add some extra amount that have appeared in the stash `free_balance` into the balance up",
                " for staking.",
                "",
                " Use this if there are additional funds in your stash account that you wish to bond.",
                " Unlike [`bond`] or [`unbond`] this function does not impose any limitation on the amount",
                " that can be added.",
                "",
                " The dispatch origin for this call must be _Signed_ by the stash, not the controller.",
                "",
                " # <weight>",
                " - Independent of the arguments. Insignificant complexity.",
                " - O(1).",
                " - One DB entry.",
                " # </weight>"
              ]
            },
            {
              "name": "unbond",
              "args": [
                {
                  "name": "value",
                  "type": "Compact<BalanceOf>"
                }
              ],
              "documentation": [
                " Schedule a portion of the stash to be unlocked ready for transfer out after the bond",
                " period ends. If this leaves an amount actively bonded less than",
                " T::Currency::minimum_balance(), then it is increased to the full amount.",
                "",
                " Once the unlock period is done, you can call `withdraw_unbonded` to actually move",
                " the funds out of management ready for transfer.",
                "",
                " No more than a limited number of unlocking chunks (see `MAX_UNLOCKING_CHUNKS`)",
                " can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need",
                " to be called first to remove some of the chunks (if possible).",
                "",
                " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
                "",
                " See also [`Call::withdraw_unbonded`].",
                "",
                " # <weight>",
                " - Independent of the arguments. Limited but potentially exploitable complexity.",
                " - Contains a limited number of reads.",
                " - Each call (requires the remainder of the bonded balance to be above `minimum_balance`)",
                "   will cause a new entry to be inserted into a vector (`Ledger.unlocking`) kept in storage.",
                "   The only way to clean the aforementioned storage item is also user-controlled via `withdraw_unbonded`.",
                " - One DB entry.",
                " </weight>"
              ]
            },
            {
              "name": "withdraw_unbonded",
              "args": [],
              "documentation": [
                " Remove any unlocked chunks from the `unlocking` queue from our management.",
                "",
                " This essentially frees up that balance to be used by the stash account to do",
                " whatever it wants.",
                "",
                " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
                "",
                " See also [`Call::unbond`].",
                "",
                " # <weight>",
                " - Could be dependent on the `origin` argument and how much `unlocking` chunks exist.",
                "  It implies `consolidate_unlocked` which loops over `Ledger.unlocking`, which is",
                "  indirectly user-controlled. See [`unbond`] for more detail.",
                " - Contains a limited number of reads, yet the size of which could be large based on `ledger`.",
                " - Writes are limited to the `origin` account key.",
                " # </weight>"
              ]
            },
            {
              "name": "validate",
              "args": [
                {
                  "name": "prefs",
                  "type": "ValidatorPrefs"
                }
              ],
              "documentation": [
                " Declare the desire to validate for the origin controller.",
                "",
                " Effects will be felt at the beginning of the next era.",
                "",
                " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
                "",
                " # <weight>",
                " - Independent of the arguments. Insignificant complexity.",
                " - Contains a limited number of reads.",
                " - Writes are limited to the `origin` account key.",
                " # </weight>"
              ]
            },
            {
              "name": "nominate",
              "args": [
                {
                  "name": "targets",
                  "type": "Vec<Address>"
                }
              ],
              "documentation": [
                " Declare the desire to nominate `targets` for the origin controller.",
                "",
                " Effects will be felt at the beginning of the next era.",
                "",
                " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
                "",
                " # <weight>",
                " - The transaction's complexity is proportional to the size of `targets`,",
                " which is capped at `MAX_NOMINATIONS`.",
                " - Both the reads and writes follow a similar pattern.",
                " # </weight>"
              ]
            },
            {
              "name": "chill",
              "args": [],
              "documentation": [
                " Declare no desire to either validate or nominate.",
                "",
                " Effects will be felt at the beginning of the next era.",
                "",
                " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
                "",
                " # <weight>",
                " - Independent of the arguments. Insignificant complexity.",
                " - Contains one read.",
                " - Writes are limited to the `origin` account key.",
                " # </weight>"
              ]
            },
            {
              "name": "set_payee",
              "args": [
                {
                  "name": "payee",
                  "type": "RewardDestination"
                }
              ],
              "documentation": [
                " (Re-)set the payment target for a controller.",
                "",
                " Effects will be felt at the beginning of the next era.",
                "",
                " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
                "",
                " # <weight>",
                " - Independent of the arguments. Insignificant complexity.",
                " - Contains a limited number of reads.",
                " - Writes are limited to the `origin` account key.",
                " # </weight>"
              ]
            },
            {
              "name": "set_controller",
              "args": [
                {
                  "name": "controller",
                  "type": "Address"
                }
              ],
              "documentation": [
                " (Re-)set the controller of a stash.",
                "",
                " Effects will be felt at the beginning of the next era.",
                "",
                " The dispatch origin for this call must be _Signed_ by the stash, not the controller.",
                "",
                " # <weight>",
                " - Independent of the arguments. Insignificant complexity.",
                " - Contains a limited number of reads.",
                " - Writes are limited to the `origin` account key.",
                " # </weight>"
              ]
            },
            {
              "name": "set_validator_count",
              "args": [
                {
                  "name": "new",
                  "type": "Compact<u32>"
                }
              ],
              "documentation": [
                " The ideal number of validators."
              ]
            },
            {
              "name": "force_no_eras",
              "args": [],
              "documentation": [
                " Force there to be no new eras indefinitely.",
                "",
                " # <weight>",
                " - No arguments.",
                " # </weight>"
              ]
            },
            {
              "name": "force_new_era",
              "args": [],
              "documentation": [
                " Force there to be a new era at the end of the next session. After this, it will be",
                " reset to normal (non-forced) behaviour.",
                "",
                " # <weight>",
                " - No arguments.",
                " # </weight>"
              ]
            },
            {
              "name": "set_invulnerables",
              "args": [
                {
                  "name": "validators",
                  "type": "Vec<AccountId>"
                }
              ],
              "documentation": [
                " Set the validators who cannot be slashed (if any)."
              ]
            }
          ],
          "events": [
            {
              "name": "Reward",
              "args": [
                "Balance"
              ],
              "documentation": [
                " All validators have been rewarded by the given balance."
              ]
            },
            {
              "name": "Slash",
              "args": [
                "AccountId",
                "Balance"
              ],
              "documentation": [
                " One validator (and its nominators) has been slashed by the given amount."
              ]
            },
            {
              "name": "OldSlashingReportDiscarded",
              "args": [
                "SessionIndex"
              ],
              "documentation": [
                " An old slashing report from a prior era was discarded because it could",
                " not be processed."
              ]
            }
          ],
          "constants": [
            {
              "name": "SessionsPerEra",
              "type": "SessionIndex",
              "value": "0x06000000",
              "documentation": [
                " Number of sessions per era."
              ]
            },
            {
              "name": "BondingDuration",
              "type": "EraIndex",
              "value": "0x1c000000",
              "documentation": [
                " Number of eras that staked funds must remain bonded for."
              ]
            }
          ]
        },
        {
          "name": "Offences",
          "storage": {
            "prefix": "Offences",
            "items": [
              {
                "name": "Reports",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "ReportIdOf",
                    "value": "OffenceDetails",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " The primary structure that holds all offence records keyed by report identifiers."
                ]
              },
              {
                "name": "ConcurrentReportsIndex",
                "modifier": "default",
                "type": {
                  "DoubleMap": {
                    "hasher": "blake2256",
                    "key1": "Kind",
                    "key2": "OpaqueTimeSlot",
                    "value": "Vec<ReportIdOf>",
                    "key2Hasher": "blake2256"
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " A vector of reports of the same kind that happened at the same time slot."
                ]
              },
              {
                "name": "ReportsByKindIndex",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "Kind",
                    "value": "Bytes",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Enumerates all reports of a kind along with the time they happened.",
                  "",
                  " All reports are sorted by the time of offence.",
                  "",
                  " Note that the actual type of this mapping is `Vec<u8>`, this is because values of",
                  " different types are not supported at the moment so we are doing the manual serialization."
                ]
              }
            ]
          },
          "calls": [],
          "events": [
            {
              "name": "Offence",
              "args": [
                "Kind",
                "OpaqueTimeSlot"
              ],
              "documentation": [
                " There is an offence reported of the given `kind` happened at the `session_index` and",
                " (kind-specific) time slot. This event is not deposited for duplicate slashes."
              ]
            }
          ],
          "constants": []
        },
        {
          "name": "Session",
          "storage": {
            "prefix": "Session",
            "items": [
              {
                "name": "Validators",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<ValidatorId>"
                },
                "fallback": "0x00",
                "documentation": [
                  " The current set of validators."
                ]
              },
              {
                "name": "CurrentIndex",
                "modifier": "default",
                "type": {
                  "Plain": "SessionIndex"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " Current index of the session."
                ]
              },
              {
                "name": "QueuedChanged",
                "modifier": "default",
                "type": {
                  "Plain": "bool"
                },
                "fallback": "0x00",
                "documentation": [
                  " True if the underlying economic identities or weighting behind the validators",
                  " has changed in the queued validator set."
                ]
              },
              {
                "name": "QueuedKeys",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<(ValidatorId,Keys)>"
                },
                "fallback": "0x00",
                "documentation": [
                  " The queued keys for the next session. When the next session begins, these keys",
                  " will be used to determine the validator's session keys."
                ]
              },
              {
                "name": "DisabledValidators",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<u32>"
                },
                "fallback": "0x00",
                "documentation": [
                  " Indices of disabled validators.",
                  "",
                  " The set is cleared when `on_session_ending` returns a new set of identities."
                ]
              },
              {
                "name": "NextKeys",
                "modifier": "optional",
                "type": {
                  "DoubleMap": {
                    "hasher": "twox64Concat",
                    "key1": "Bytes",
                    "key2": "ValidatorId",
                    "value": "Keys",
                    "key2Hasher": "blake2256"
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " The next session keys for a validator.",
                  "",
                  " The first key is always `DEDUP_KEY_PREFIX` to have all the data in the same branch of",
                  " the trie. Having all data in the same branch should prevent slowing down other queries."
                ]
              },
              {
                "name": "KeyOwner",
                "modifier": "optional",
                "type": {
                  "DoubleMap": {
                    "hasher": "twox64Concat",
                    "key1": "Bytes",
                    "key2": "(KeyTypeId,Bytes)",
                    "value": "ValidatorId",
                    "key2Hasher": "blake2256"
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " The owner of a key. The second key is the `KeyTypeId` + the encoded key.",
                  "",
                  " The first key is always `DEDUP_KEY_PREFIX` to have all the data in the same branch of",
                  " the trie. Having all data in the same branch should prevent slowing down other queries."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "set_keys",
              "args": [
                {
                  "name": "keys",
                  "type": "Keys"
                },
                {
                  "name": "proof",
                  "type": "Bytes"
                }
              ],
              "documentation": [
                " Sets the session key(s) of the function caller to `key`.",
                " Allows an account to set its session key prior to becoming a validator.",
                " This doesn't take effect until the next session.",
                "",
                " The dispatch origin of this function must be signed.",
                "",
                " # <weight>",
                " - O(log n) in number of accounts.",
                " - One extra DB entry.",
                " # </weight>"
              ]
            }
          ],
          "events": [
            {
              "name": "NewSession",
              "args": [
                "SessionIndex"
              ],
              "documentation": [
                " New session has happened. Note that the argument is the session index, not the block",
                " number as the type might suggest."
              ]
            }
          ],
          "constants": [
            {
              "name": "DEDUP_KEY_PREFIX",
              "type": "Bytes",
              "value": "0x343a73657373696f6e3a6b657973",
              "documentation": [
                " Used as first key for `NextKeys` and `KeyOwner` to put all the data into the same branch",
                " of the trie."
              ]
            }
          ]
        },
        {
          "name": "FinalityTracker",
          "storage": null,
          "calls": [
            {
              "name": "final_hint",
              "args": [
                {
                  "name": "hint",
                  "type": "Compact<BlockNumber>"
                }
              ],
              "documentation": [
                " Hint that the author of this block thinks the best finalized",
                " block is the given number."
              ]
            }
          ],
          "events": null,
          "constants": [
            {
              "name": "WindowSize",
              "type": "BlockNumber",
              "value": "0x65000000",
              "documentation": [
                " The number of recent samples to keep from this chain. Default is 101."
              ]
            },
            {
              "name": "ReportLatency",
              "type": "BlockNumber",
              "value": "0xe8030000",
              "documentation": [
                " The delay after which point things become suspicious. Default is 1000."
              ]
            }
          ]
        },
        {
          "name": "Grandpa",
          "storage": {
            "prefix": "GrandpaFinality",
            "items": [
              {
                "name": "Authorities",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<(AuthorityId,AuthorityWeight)>"
                },
                "fallback": "0x00",
                "documentation": [
                  " The current authority set."
                ]
              },
              {
                "name": "State",
                "modifier": "default",
                "type": {
                  "Plain": "StoredState"
                },
                "fallback": "0x00",
                "documentation": [
                  " State of the current authority set."
                ]
              },
              {
                "name": "PendingChange",
                "modifier": "optional",
                "type": {
                  "Plain": "StoredPendingChange"
                },
                "fallback": "0x00",
                "documentation": [
                  " Pending change: (signaled at, scheduled change)."
                ]
              },
              {
                "name": "NextForced",
                "modifier": "optional",
                "type": {
                  "Plain": "BlockNumber"
                },
                "fallback": "0x00",
                "documentation": [
                  " next block number where we can force a change."
                ]
              },
              {
                "name": "Stalled",
                "modifier": "optional",
                "type": {
                  "Plain": "(BlockNumber,BlockNumber)"
                },
                "fallback": "0x00",
                "documentation": [
                  " `true` if we are currently stalled."
                ]
              },
              {
                "name": "CurrentSetId",
                "modifier": "default",
                "type": {
                  "Plain": "SetId"
                },
                "fallback": "0x0000000000000000",
                "documentation": [
                  " The number of changes (both in terms of keys and underlying economic responsibilities)",
                  " in the \"set\" of Grandpa validators from genesis."
                ]
              },
              {
                "name": "SetIdSession",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "SetId",
                    "value": "SessionIndex",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " A mapping from grandpa set ID to the index of the *most recent* session for which its members were responsible."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "report_misbehavior",
              "args": [
                {
                  "name": "_report",
                  "type": "Bytes"
                }
              ],
              "documentation": [
                " Report some misbehavior."
              ]
            }
          ],
          "events": [
            {
              "name": "NewAuthorities",
              "args": [
                "Vec<(AuthorityId,AuthorityWeight)>"
              ],
              "documentation": [
                " New authority set has been applied."
              ]
            },
            {
              "name": "Paused",
              "args": [],
              "documentation": [
                " Current authority set has been paused."
              ]
            },
            {
              "name": "Resumed",
              "args": [],
              "documentation": [
                " Current authority set has been resumed."
              ]
            }
          ],
          "constants": []
        },
        {
          "name": "ImOnline",
          "storage": {
            "prefix": "ImOnline",
            "items": [
              {
                "name": "GossipAt",
                "modifier": "default",
                "type": {
                  "Plain": "BlockNumber"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " The block number when we should gossip."
                ]
              },
              {
                "name": "Keys",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<AuthorityId>"
                },
                "fallback": "0x00",
                "documentation": [
                  " The current set of keys that may issue a heartbeat."
                ]
              },
              {
                "name": "ReceivedHeartbeats",
                "modifier": "default",
                "type": {
                  "DoubleMap": {
                    "hasher": "blake2256",
                    "key1": "SessionIndex",
                    "key2": "AuthIndex",
                    "value": "Bytes",
                    "key2Hasher": "blake2256"
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " For each session index we keep a mapping of `AuthorityId`",
                  " to `offchain::OpaqueNetworkState`."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "heartbeat",
              "args": [
                {
                  "name": "heartbeat",
                  "type": "Heartbeat"
                },
                {
                  "name": "signature",
                  "type": "Signature"
                }
              ],
              "documentation": []
            }
          ],
          "events": [
            {
              "name": "HeartbeatReceived",
              "args": [
                "AuthorityId"
              ],
              "documentation": [
                " A new heartbeat was received from `AuthorityId`"
              ]
            }
          ],
          "constants": []
        },
        {
          "name": "AuthorityDiscovery",
          "storage": null,
          "calls": [],
          "events": null,
          "constants": []
        },
        {
          "name": "Democracy",
          "storage": {
            "prefix": "Democracy",
            "items": [
              {
                "name": "PublicPropCount",
                "modifier": "default",
                "type": {
                  "Plain": "PropIndex"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " The number of (public) proposals that have been made so far."
                ]
              },
              {
                "name": "PublicProps",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<(PropIndex,Proposal,AccountId)>"
                },
                "fallback": "0x00",
                "documentation": [
                  " The public proposals. Unsorted."
                ]
              },
              {
                "name": "DepositOf",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "PropIndex",
                    "value": "(BalanceOf,Vec<AccountId>)",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Those who have locked a deposit."
                ]
              },
              {
                "name": "ReferendumCount",
                "modifier": "default",
                "type": {
                  "Plain": "ReferendumIndex"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " The next free referendum index, aka the number of referenda started so far."
                ]
              },
              {
                "name": "NextTally",
                "modifier": "default",
                "type": {
                  "Plain": "ReferendumIndex"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " The next referendum index that should be tallied."
                ]
              },
              {
                "name": "ReferendumInfoOf",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "ReferendumIndex",
                    "value": "ReferendumInfo",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Information concerning any given referendum."
                ]
              },
              {
                "name": "DispatchQueue",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "BlockNumber",
                    "value": "Vec<Option<(Proposal,ReferendumIndex)>>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Queue of successful referenda to be dispatched."
                ]
              },
              {
                "name": "VotersFor",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "ReferendumIndex",
                    "value": "Vec<AccountId>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Get the voters for the current proposal."
                ]
              },
              {
                "name": "VoteOf",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "(ReferendumIndex,AccountId)",
                    "value": "Vote",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Get the vote in a given referendum of a particular voter. The result is meaningful only",
                  " if `voters_for` includes the voter when called with the referendum (you'll get the",
                  " default `Vote` value otherwise). If you don't want to check `voters_for`, then you can",
                  " also check for simple existence with `VoteOf::exists` first."
                ]
              },
              {
                "name": "Proxy",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "AccountId",
                    "value": "AccountId",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Who is able to vote for whom. Value is the fund-holding account, key is the",
                  " vote-transaction-sending account."
                ]
              },
              {
                "name": "Delegations",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "AccountId",
                    "value": "(AccountId,Conviction)",
                    "linked": true
                  }
                },
                "fallback": "0x000000000000000000000000000000000000000000000000000000000000000000",
                "documentation": [
                  " Get the account (and lock periods) to which another account is delegating vote."
                ]
              },
              {
                "name": "LastTabledWasExternal",
                "modifier": "default",
                "type": {
                  "Plain": "bool"
                },
                "fallback": "0x00",
                "documentation": [
                  " True if the last referendum tabled was submitted externally. False if it was a public",
                  " proposal."
                ]
              },
              {
                "name": "NextExternal",
                "modifier": "optional",
                "type": {
                  "Plain": "(Proposal,VoteThreshold)"
                },
                "fallback": "0x00",
                "documentation": [
                  " The referendum to be tabled whenever it would be valid to table an external proposal.",
                  " This happens when a referendum needs to be tabled and one of two conditions are met:",
                  " - `LastTabledWasExternal` is `false`; or",
                  " - `PublicProps` is empty."
                ]
              },
              {
                "name": "Blacklist",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "Hash",
                    "value": "(BlockNumber,Vec<AccountId>)",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " A record of who vetoed what. Maps proposal hash to a possible existent block number",
                  " (until when it may not be resubmitted) and who vetoed it."
                ]
              },
              {
                "name": "Cancellations",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "Hash",
                    "value": "bool",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Record of all proposals that have been subject to emergency cancellation."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "propose",
              "args": [
                {
                  "name": "proposal",
                  "type": "Proposal"
                },
                {
                  "name": "value",
                  "type": "Compact<BalanceOf>"
                }
              ],
              "documentation": [
                " Propose a sensitive action to be taken.",
                "",
                " # <weight>",
                " - O(1).",
                " - Two DB changes, one DB entry.",
                " # </weight>"
              ]
            },
            {
              "name": "second",
              "args": [
                {
                  "name": "proposal",
                  "type": "Compact<PropIndex>"
                }
              ],
              "documentation": [
                " Propose a sensitive action to be taken.",
                "",
                " # <weight>",
                " - O(1).",
                " - One DB entry.",
                " # </weight>"
              ]
            },
            {
              "name": "vote",
              "args": [
                {
                  "name": "ref_index",
                  "type": "Compact<ReferendumIndex>"
                },
                {
                  "name": "vote",
                  "type": "Vote"
                }
              ],
              "documentation": [
                " Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;",
                " otherwise it is a vote to keep the status quo.",
                "",
                " # <weight>",
                " - O(1).",
                " - One DB change, one DB entry.",
                " # </weight>"
              ]
            },
            {
              "name": "proxy_vote",
              "args": [
                {
                  "name": "ref_index",
                  "type": "Compact<ReferendumIndex>"
                },
                {
                  "name": "vote",
                  "type": "Vote"
                }
              ],
              "documentation": [
                " Vote in a referendum on behalf of a stash. If `vote.is_aye()`, the vote is to enact",
                " the proposal;  otherwise it is a vote to keep the status quo.",
                "",
                " # <weight>",
                " - O(1).",
                " - One DB change, one DB entry.",
                " # </weight>"
              ]
            },
            {
              "name": "emergency_cancel",
              "args": [
                {
                  "name": "ref_index",
                  "type": "ReferendumIndex"
                }
              ],
              "documentation": [
                " Schedule an emergency cancellation of a referendum. Cannot happen twice to the same",
                " referendum."
              ]
            },
            {
              "name": "external_propose",
              "args": [
                {
                  "name": "proposal",
                  "type": "Proposal"
                }
              ],
              "documentation": [
                " Schedule a referendum to be tabled once it is legal to schedule an external",
                " referendum."
              ]
            },
            {
              "name": "external_propose_majority",
              "args": [
                {
                  "name": "proposal",
                  "type": "Proposal"
                }
              ],
              "documentation": [
                " Schedule a majority-carries referendum to be tabled next once it is legal to schedule",
                " an external referendum.",
                "",
                " Unlike `external_propose`, blacklisting has no effect on this and it may replace a",
                " pre-scheduled `external_propose` call."
              ]
            },
            {
              "name": "external_propose_default",
              "args": [
                {
                  "name": "proposal",
                  "type": "Proposal"
                }
              ],
              "documentation": [
                " Schedule a negative-turnout-bias referendum to be tabled next once it is legal to",
                " schedule an external referendum.",
                "",
                " Unlike `external_propose`, blacklisting has no effect on this and it may replace a",
                " pre-scheduled `external_propose` call."
              ]
            },
            {
              "name": "fast_track",
              "args": [
                {
                  "name": "proposal_hash",
                  "type": "Hash"
                },
                {
                  "name": "voting_period",
                  "type": "BlockNumber"
                },
                {
                  "name": "delay",
                  "type": "BlockNumber"
                }
              ],
              "documentation": [
                " Schedule the currently externally-proposed majority-carries referendum to be tabled",
                " immediately. If there is no externally-proposed referendum currently, or if there is one",
                " but it is not a majority-carries referendum then it fails.",
                "",
                " - `proposal_hash`: The hash of the current external proposal.",
                " - `voting_period`: The period that is allowed for voting on this proposal.",
                " - `delay`: The number of block after voting has ended in approval and this should be",
                "   enacted. Increased to `EmergencyVotingPeriod` if too low."
              ]
            },
            {
              "name": "veto_external",
              "args": [
                {
                  "name": "proposal_hash",
                  "type": "Hash"
                }
              ],
              "documentation": [
                " Veto and blacklist the external proposal hash."
              ]
            },
            {
              "name": "cancel_referendum",
              "args": [
                {
                  "name": "ref_index",
                  "type": "Compact<ReferendumIndex>"
                }
              ],
              "documentation": [
                " Remove a referendum."
              ]
            },
            {
              "name": "cancel_queued",
              "args": [
                {
                  "name": "when",
                  "type": "Compact<BlockNumber>"
                },
                {
                  "name": "which",
                  "type": "Compact<u32>"
                },
                {
                  "name": "what",
                  "type": "Compact<ReferendumIndex>"
                }
              ],
              "documentation": [
                " Cancel a proposal queued for enactment."
              ]
            },
            {
              "name": "set_proxy",
              "args": [
                {
                  "name": "proxy",
                  "type": "AccountId"
                }
              ],
              "documentation": [
                " Specify a proxy. Called by the stash.",
                "",
                " # <weight>",
                " - One extra DB entry.",
                " # </weight>"
              ]
            },
            {
              "name": "resign_proxy",
              "args": [],
              "documentation": [
                " Clear the proxy. Called by the proxy.",
                "",
                " # <weight>",
                " - One DB clear.",
                " # </weight>"
              ]
            },
            {
              "name": "remove_proxy",
              "args": [
                {
                  "name": "proxy",
                  "type": "AccountId"
                }
              ],
              "documentation": [
                " Clear the proxy. Called by the stash.",
                "",
                " # <weight>",
                " - One DB clear.",
                " # </weight>"
              ]
            },
            {
              "name": "delegate",
              "args": [
                {
                  "name": "to",
                  "type": "AccountId"
                },
                {
                  "name": "conviction",
                  "type": "Conviction"
                }
              ],
              "documentation": [
                " Delegate vote.",
                "",
                " # <weight>",
                " - One extra DB entry.",
                " # </weight>"
              ]
            },
            {
              "name": "undelegate",
              "args": [],
              "documentation": [
                " Undelegate vote.",
                "",
                " # <weight>",
                " - O(1).",
                " # </weight>"
              ]
            }
          ],
          "events": [
            {
              "name": "Proposed",
              "args": [
                "PropIndex",
                "Balance"
              ],
              "documentation": []
            },
            {
              "name": "Tabled",
              "args": [
                "PropIndex",
                "Balance",
                "Vec<AccountId>"
              ],
              "documentation": []
            },
            {
              "name": "ExternalTabled",
              "args": [],
              "documentation": []
            },
            {
              "name": "Started",
              "args": [
                "ReferendumIndex",
                "VoteThreshold"
              ],
              "documentation": []
            },
            {
              "name": "Passed",
              "args": [
                "ReferendumIndex"
              ],
              "documentation": []
            },
            {
              "name": "NotPassed",
              "args": [
                "ReferendumIndex"
              ],
              "documentation": []
            },
            {
              "name": "Cancelled",
              "args": [
                "ReferendumIndex"
              ],
              "documentation": []
            },
            {
              "name": "Executed",
              "args": [
                "ReferendumIndex",
                "bool"
              ],
              "documentation": []
            },
            {
              "name": "Delegated",
              "args": [
                "AccountId",
                "AccountId"
              ],
              "documentation": []
            },
            {
              "name": "Undelegated",
              "args": [
                "AccountId"
              ],
              "documentation": []
            },
            {
              "name": "Vetoed",
              "args": [
                "AccountId",
                "Hash",
                "BlockNumber"
              ],
              "documentation": []
            }
          ],
          "constants": [
            {
              "name": "EnactmentPeriod",
              "type": "BlockNumber",
              "value": "0x80970600",
              "documentation": [
                " The minimum period of locking and the period between a proposal being approved and enacted.",
                "",
                " It should generally be a little more than the unstake period to ensure that",
                " voting stakers have an opportunity to remove themselves from the system in the case where",
                " they are on the losing side of a vote."
              ]
            },
            {
              "name": "LaunchPeriod",
              "type": "BlockNumber",
              "value": "0x00270600",
              "documentation": [
                " How often (in blocks) new public referenda are launched."
              ]
            },
            {
              "name": "VotingPeriod",
              "type": "BlockNumber",
              "value": "0x00270600",
              "documentation": [
                " How often (in blocks) to check for new votes."
              ]
            },
            {
              "name": "MinimumDeposit",
              "type": "BalanceOf",
              "value": "0x0010a5d4e80000000000000000000000",
              "documentation": [
                " The minimum amount to be used as a deposit for a public referendum proposal."
              ]
            },
            {
              "name": "EmergencyVotingPeriod",
              "type": "BlockNumber",
              "value": "0xc0a80000",
              "documentation": [
                " Minimum voting period allowed for an emergency referendum."
              ]
            },
            {
              "name": "CooloffPeriod",
              "type": "BlockNumber",
              "value": "0x00270600",
              "documentation": [
                " Period in blocks where an external proposal may not be re-submitted after being vetoed."
              ]
            }
          ]
        },
        {
          "name": "Council",
          "storage": {
            "prefix": "Instance1Collective",
            "items": [
              {
                "name": "Proposals",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<Hash>"
                },
                "fallback": "0x00",
                "documentation": [
                  " The hashes of the active proposals."
                ]
              },
              {
                "name": "ProposalOf",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "Hash",
                    "value": "Proposal",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Actual proposal for a given hash, if it's current."
                ]
              },
              {
                "name": "Voting",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "Hash",
                    "value": "Votes",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Votes on a given proposal, if it is ongoing."
                ]
              },
              {
                "name": "ProposalCount",
                "modifier": "default",
                "type": {
                  "Plain": "u32"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " Proposals so far."
                ]
              },
              {
                "name": "Members",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<AccountId>"
                },
                "fallback": "0x00",
                "documentation": [
                  " The current members of the collective. This is stored sorted (just by value)."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "set_members",
              "args": [
                {
                  "name": "new_members",
                  "type": "Vec<AccountId>"
                }
              ],
              "documentation": [
                " Set the collective's membership manually to `new_members`. Be nice to the chain and",
                " provide it pre-sorted.",
                "",
                " Requires root origin."
              ]
            },
            {
              "name": "execute",
              "args": [
                {
                  "name": "proposal",
                  "type": "Proposal"
                }
              ],
              "documentation": [
                " Dispatch a proposal from a member using the `Member` origin.",
                "",
                " Origin must be a member of the collective."
              ]
            },
            {
              "name": "propose",
              "args": [
                {
                  "name": "threshold",
                  "type": "Compact<MemberCount>"
                },
                {
                  "name": "proposal",
                  "type": "Proposal"
                }
              ],
              "documentation": [
                " # <weight>",
                " - Bounded storage reads and writes.",
                " - Argument `threshold` has bearing on weight.",
                " # </weight>"
              ]
            },
            {
              "name": "vote",
              "args": [
                {
                  "name": "proposal",
                  "type": "Hash"
                },
                {
                  "name": "index",
                  "type": "Compact<ProposalIndex>"
                },
                {
                  "name": "approve",
                  "type": "bool"
                }
              ],
              "documentation": [
                " # <weight>",
                " - Bounded storage read and writes.",
                " - Will be slightly heavier if the proposal is approved / disapproved after the vote.",
                " # </weight>"
              ]
            }
          ],
          "events": [
            {
              "name": "Proposed",
              "args": [
                "AccountId",
                "ProposalIndex",
                "Hash",
                "MemberCount"
              ],
              "documentation": [
                " A motion (given hash) has been proposed (by given account) with a threshold (given",
                " `MemberCount`)."
              ]
            },
            {
              "name": "Voted",
              "args": [
                "AccountId",
                "Hash",
                "bool",
                "MemberCount",
                "MemberCount"
              ],
              "documentation": [
                " A motion (given hash) has been voted on by given account, leaving",
                " a tally (yes votes and no votes given respectively as `MemberCount`)."
              ]
            },
            {
              "name": "Approved",
              "args": [
                "Hash"
              ],
              "documentation": [
                " A motion was approved by the required threshold."
              ]
            },
            {
              "name": "Disapproved",
              "args": [
                "Hash"
              ],
              "documentation": [
                " A motion was not approved by the required threshold."
              ]
            },
            {
              "name": "Executed",
              "args": [
                "Hash",
                "bool"
              ],
              "documentation": [
                " A motion was executed; `bool` is true if returned without error."
              ]
            },
            {
              "name": "MemberExecuted",
              "args": [
                "Hash",
                "bool"
              ],
              "documentation": [
                " A single member did some action; `bool` is true if returned without error."
              ]
            }
          ],
          "constants": []
        },
        {
          "name": "TechnicalCommittee",
          "storage": {
            "prefix": "Instance2Collective",
            "items": [
              {
                "name": "Proposals",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<Hash>"
                },
                "fallback": "0x00",
                "documentation": [
                  " The hashes of the active proposals."
                ]
              },
              {
                "name": "ProposalOf",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "Hash",
                    "value": "Proposal",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Actual proposal for a given hash, if it's current."
                ]
              },
              {
                "name": "Voting",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "Hash",
                    "value": "Votes",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Votes on a given proposal, if it is ongoing."
                ]
              },
              {
                "name": "ProposalCount",
                "modifier": "default",
                "type": {
                  "Plain": "u32"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " Proposals so far."
                ]
              },
              {
                "name": "Members",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<AccountId>"
                },
                "fallback": "0x00",
                "documentation": [
                  " The current members of the collective. This is stored sorted (just by value)."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "set_members",
              "args": [
                {
                  "name": "new_members",
                  "type": "Vec<AccountId>"
                }
              ],
              "documentation": [
                " Set the collective's membership manually to `new_members`. Be nice to the chain and",
                " provide it pre-sorted.",
                "",
                " Requires root origin."
              ]
            },
            {
              "name": "execute",
              "args": [
                {
                  "name": "proposal",
                  "type": "Proposal"
                }
              ],
              "documentation": [
                " Dispatch a proposal from a member using the `Member` origin.",
                "",
                " Origin must be a member of the collective."
              ]
            },
            {
              "name": "propose",
              "args": [
                {
                  "name": "threshold",
                  "type": "Compact<MemberCount>"
                },
                {
                  "name": "proposal",
                  "type": "Proposal"
                }
              ],
              "documentation": [
                " # <weight>",
                " - Bounded storage reads and writes.",
                " - Argument `threshold` has bearing on weight.",
                " # </weight>"
              ]
            },
            {
              "name": "vote",
              "args": [
                {
                  "name": "proposal",
                  "type": "Hash"
                },
                {
                  "name": "index",
                  "type": "Compact<ProposalIndex>"
                },
                {
                  "name": "approve",
                  "type": "bool"
                }
              ],
              "documentation": [
                " # <weight>",
                " - Bounded storage read and writes.",
                " - Will be slightly heavier if the proposal is approved / disapproved after the vote.",
                " # </weight>"
              ]
            }
          ],
          "events": [
            {
              "name": "Proposed",
              "args": [
                "AccountId",
                "ProposalIndex",
                "Hash",
                "MemberCount"
              ],
              "documentation": [
                " A motion (given hash) has been proposed (by given account) with a threshold (given",
                " `MemberCount`)."
              ]
            },
            {
              "name": "Voted",
              "args": [
                "AccountId",
                "Hash",
                "bool",
                "MemberCount",
                "MemberCount"
              ],
              "documentation": [
                " A motion (given hash) has been voted on by given account, leaving",
                " a tally (yes votes and no votes given respectively as `MemberCount`)."
              ]
            },
            {
              "name": "Approved",
              "args": [
                "Hash"
              ],
              "documentation": [
                " A motion was approved by the required threshold."
              ]
            },
            {
              "name": "Disapproved",
              "args": [
                "Hash"
              ],
              "documentation": [
                " A motion was not approved by the required threshold."
              ]
            },
            {
              "name": "Executed",
              "args": [
                "Hash",
                "bool"
              ],
              "documentation": [
                " A motion was executed; `bool` is true if returned without error."
              ]
            },
            {
              "name": "MemberExecuted",
              "args": [
                "Hash",
                "bool"
              ],
              "documentation": [
                " A single member did some action; `bool` is true if returned without error."
              ]
            }
          ],
          "constants": []
        },
        {
          "name": "Elections",
          "storage": {
            "prefix": "Council",
            "items": [
              {
                "name": "PresentationDuration",
                "modifier": "default",
                "type": {
                  "Plain": "BlockNumber"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " How long to give each top candidate to present themselves after the vote ends."
                ]
              },
              {
                "name": "TermDuration",
                "modifier": "default",
                "type": {
                  "Plain": "BlockNumber"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " How long each position is active for."
                ]
              },
              {
                "name": "DesiredSeats",
                "modifier": "default",
                "type": {
                  "Plain": "u32"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " Number of accounts that should constitute the collective."
                ]
              },
              {
                "name": "Members",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<(AccountId,BlockNumber)>"
                },
                "fallback": "0x00",
                "documentation": [
                  "  The current membership. When there's a vote going on, this should still be used for",
                  "  executive matters. The block number (second element in the tuple) is the block that",
                  "  their position is active until (calculated by the sum of the block number when the",
                  "  member was elected and their term duration)."
                ]
              },
              {
                "name": "VoteCount",
                "modifier": "default",
                "type": {
                  "Plain": "VoteIndex"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " The total number of vote rounds that have happened or are in progress."
                ]
              },
              {
                "name": "ApprovalsOf",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "(AccountId,SetIndex)",
                    "value": "Vec<ApprovalFlag>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": []
              },
              {
                "name": "RegisterInfoOf",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "AccountId",
                    "value": "(VoteIndex,u32)",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " The vote index and list slot that the candidate `who` was registered or `None` if they",
                  " are not currently registered."
                ]
              },
              {
                "name": "VoterInfoOf",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "AccountId",
                    "value": "VoterInfo",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Basic information about a voter."
                ]
              },
              {
                "name": "Voters",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "SetIndex",
                    "value": "Vec<Option<AccountId>>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " The present voter list (chunked and capped at [`VOTER_SET_SIZE`])."
                ]
              },
              {
                "name": "NextVoterSet",
                "modifier": "default",
                "type": {
                  "Plain": "SetIndex"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " the next free set to store a voter in. This will keep growing."
                ]
              },
              {
                "name": "VoterCount",
                "modifier": "default",
                "type": {
                  "Plain": "SetIndex"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " Current number of Voters."
                ]
              },
              {
                "name": "Candidates",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<AccountId>"
                },
                "fallback": "0x00",
                "documentation": [
                  " The present candidate list."
                ]
              },
              {
                "name": "CandidateCount",
                "modifier": "default",
                "type": {
                  "Plain": "u32"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " Current number of active candidates"
                ]
              },
              {
                "name": "NextFinalize",
                "modifier": "optional",
                "type": {
                  "Plain": "(BlockNumber,u32,Vec<AccountId>)"
                },
                "fallback": "0x00",
                "documentation": [
                  " The accounts holding the seats that will become free on the next tally."
                ]
              },
              {
                "name": "Leaderboard",
                "modifier": "optional",
                "type": {
                  "Plain": "Vec<(BalanceOf,AccountId)>"
                },
                "fallback": "0x00",
                "documentation": [
                  " Get the leaderboard if we're in the presentation phase. The first element is the weight",
                  " of each entry; It may be the direct summed approval stakes, or a weighted version of it.",
                  " Sorted from low to high."
                ]
              },
              {
                "name": "Proxy",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "AccountId",
                    "value": "AccountId",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Who is able to vote for whom. Value is the fund-holding account, key is the",
                  " vote-transaction-sending account."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "set_approvals",
              "args": [
                {
                  "name": "votes",
                  "type": "Vec<bool>"
                },
                {
                  "name": "index",
                  "type": "Compact<VoteIndex>"
                },
                {
                  "name": "hint",
                  "type": "SetIndex"
                },
                {
                  "name": "value",
                  "type": "BalanceOf"
                }
              ],
              "documentation": [
                " Set candidate approvals. Approval slots stay valid as long as candidates in those slots",
                " are registered.",
                "",
                " Locks `value` from the balance of `origin` indefinitely. Only [`retract_voter`] or",
                " [`reap_inactive_voter`] can unlock the balance.",
                "",
                " `hint` argument is interpreted differently based on:",
                " - if `origin` is setting approvals for the first time: The index will be checked for",
                "   being a valid _hole_ in the voter list.",
                "   - if the hint is correctly pointing to a hole, no fee is deducted from `origin`.",
                "   - Otherwise, the call will succeed but the index is ignored and simply a push to the",
                "     last chunk with free space happens. If the new push causes a new chunk to be",
                "     created, a fee indicated by [`VotingFee`] is deducted.",
                " - if `origin` is already a voter: the index __must__ be valid and point to the correct",
                "   position of the `origin` in the current voters list.",
                "",
                " Note that any trailing `false` votes in `votes` is ignored; In approval voting, not",
                " voting for a candidate and voting false, are equal.",
                "",
                " # <weight>",
                " - O(1).",
                " - Two extra DB entries, one DB change.",
                " - Argument `votes` is limited in length to number of candidates.",
                " # </weight>"
              ]
            },
            {
              "name": "proxy_set_approvals",
              "args": [
                {
                  "name": "votes",
                  "type": "Vec<bool>"
                },
                {
                  "name": "index",
                  "type": "Compact<VoteIndex>"
                },
                {
                  "name": "hint",
                  "type": "SetIndex"
                },
                {
                  "name": "value",
                  "type": "BalanceOf"
                }
              ],
              "documentation": [
                " Set candidate approvals from a proxy. Approval slots stay valid as long as candidates in",
                " those slots are registered.",
                "",
                " # <weight>",
                " - Same as `set_approvals` with one additional storage read.",
                " # </weight>"
              ]
            },
            {
              "name": "reap_inactive_voter",
              "args": [
                {
                  "name": "reporter_index",
                  "type": "Compact<u32>"
                },
                {
                  "name": "who",
                  "type": "Address"
                },
                {
                  "name": "who_index",
                  "type": "Compact<u32>"
                },
                {
                  "name": "assumed_vote_index",
                  "type": "Compact<VoteIndex>"
                }
              ],
              "documentation": [
                " Remove a voter. For it not to be a bond-consuming no-op, all approved candidate indices",
                " must now be either unregistered or registered to a candidate that registered the slot",
                " after the voter gave their last approval set.",
                "",
                " Both indices must be provided as explained in [`voter_at`] function.",
                "",
                " May be called by anyone. Returns the voter deposit to `signed`.",
                "",
                " # <weight>",
                " - O(1).",
                " - Two fewer DB entries, one DB change.",
                " # </weight>"
              ]
            },
            {
              "name": "retract_voter",
              "args": [
                {
                  "name": "index",
                  "type": "Compact<u32>"
                }
              ],
              "documentation": [
                " Remove a voter. All votes are cancelled and the voter deposit is returned.",
                "",
                " The index must be provided as explained in [`voter_at`] function.",
                "",
                " Also removes the lock on the balance of the voter. See [`do_set_approvals()`].",
                "",
                " # <weight>",
                " - O(1).",
                " - Two fewer DB entries, one DB change.",
                " # </weight>"
              ]
            },
            {
              "name": "submit_candidacy",
              "args": [
                {
                  "name": "slot",
                  "type": "Compact<u32>"
                }
              ],
              "documentation": [
                " Submit oneself for candidacy.",
                "",
                " Account must have enough transferrable funds in it to pay the bond.",
                "",
                " NOTE: if `origin` has already assigned approvals via [`set_approvals`],",
                " it will NOT have any usable funds to pass candidacy bond and must first retract.",
                " Note that setting approvals will lock the entire balance of the voter until",
                " retraction or being reported.",
                "",
                " # <weight>",
                " - Independent of input.",
                " - Three DB changes.",
                " # </weight>"
              ]
            },
            {
              "name": "present_winner",
              "args": [
                {
                  "name": "candidate",
                  "type": "Address"
                },
                {
                  "name": "total",
                  "type": "Compact<BalanceOf>"
                },
                {
                  "name": "index",
                  "type": "Compact<VoteIndex>"
                }
              ],
              "documentation": [
                " Claim that `candidate` is one of the top `carry_count + desired_seats` candidates. Only",
                " works iff the presentation period is active. `candidate` should have at least collected",
                " some non-zero `total` votes and `origin` must have enough funds to pay for a potential",
                " slash.",
                "",
                " # <weight>",
                " - O(voters) compute.",
                " - One DB change.",
                " # </weight>"
              ]
            },
            {
              "name": "set_desired_seats",
              "args": [
                {
                  "name": "count",
                  "type": "Compact<u32>"
                }
              ],
              "documentation": [
                " Set the desired member count; if lower than the current count, then seats will not be up",
                " election when they expire. If more, then a new vote will be started if one is not",
                " already in progress."
              ]
            },
            {
              "name": "remove_member",
              "args": [
                {
                  "name": "who",
                  "type": "Address"
                }
              ],
              "documentation": [
                " Remove a particular member from the set. This is effective immediately.",
                "",
                " Note: A tally should happen instantly (if not already in a presentation",
                " period) to fill the seat if removal means that the desired members are not met."
              ]
            },
            {
              "name": "set_presentation_duration",
              "args": [
                {
                  "name": "count",
                  "type": "Compact<BlockNumber>"
                }
              ],
              "documentation": [
                " Set the presentation duration. If there is currently a vote being presented for, will",
                " invoke `finalize_vote`."
              ]
            },
            {
              "name": "set_term_duration",
              "args": [
                {
                  "name": "count",
                  "type": "Compact<BlockNumber>"
                }
              ],
              "documentation": [
                " Set the presentation duration. If there is current a vote being presented for, will",
                " invoke `finalize_vote`."
              ]
            }
          ],
          "events": [
            {
              "name": "VoterReaped",
              "args": [
                "AccountId",
                "AccountId"
              ],
              "documentation": [
                " reaped voter, reaper"
              ]
            },
            {
              "name": "BadReaperSlashed",
              "args": [
                "AccountId"
              ],
              "documentation": [
                " slashed reaper"
              ]
            },
            {
              "name": "TallyStarted",
              "args": [
                "u32"
              ],
              "documentation": [
                " A tally (for approval votes of seat(s)) has started."
              ]
            },
            {
              "name": "TallyFinalized",
              "args": [
                "Vec<AccountId>",
                "Vec<AccountId>"
              ],
              "documentation": [
                " A tally (for approval votes of seat(s)) has ended (with one or more new members)."
              ]
            }
          ],
          "constants": [
            {
              "name": "CandidacyBond",
              "type": "BalanceOf",
              "value": "0x00e87648170000000000000000000000",
              "documentation": [
                " How much should be locked up in order to submit one's candidacy. A reasonable",
                " default value is 9."
              ]
            },
            {
              "name": "VotingBond",
              "type": "BalanceOf",
              "value": "0x00e40b54020000000000000000000000",
              "documentation": [
                " How much should be locked up in order to be able to submit votes."
              ]
            },
            {
              "name": "VotingFee",
              "type": "BalanceOf",
              "value": "0x00c817a8040000000000000000000000",
              "documentation": [
                " The amount of fee paid upon each vote submission, unless if they submit a",
                " _hole_ index and replace it."
              ]
            },
            {
              "name": "PresentSlashPerVoter",
              "type": "BalanceOf",
              "value": "0x00e1f505000000000000000000000000",
              "documentation": [
                " The punishment, per voter, if you provide an invalid presentation. A",
                " reasonable default value is 1."
              ]
            },
            {
              "name": "CarryCount",
              "type": "u32",
              "value": "0x06000000",
              "documentation": [
                " How many runners-up should have their approvals persist until the next",
                " vote. A reasonable default value is 2."
              ]
            },
            {
              "name": "InactiveGracePeriod",
              "type": "VoteIndex",
              "value": "0x01000000",
              "documentation": [
                " How many vote indices need to go by after a target voter's last vote before",
                " they can be reaped if their approvals are moot. A reasonable default value",
                " is 1."
              ]
            },
            {
              "name": "VotingPeriod",
              "type": "BlockNumber",
              "value": "0x80700000",
              "documentation": [
                " How often (in blocks) to check for new votes. A reasonable default value",
                " is 1000."
              ]
            },
            {
              "name": "MinimumVotingLock",
              "type": "BalanceOf",
              "value": "0x00e40b54020000000000000000000000",
              "documentation": [
                " Minimum about that can be used as the locked value for voting."
              ]
            },
            {
              "name": "DecayRatio",
              "type": "u32",
              "value": "0x00000000",
              "documentation": [
                " Decay factor of weight when being accumulated. It should typically be set to",
                " __at least__ `membership_size -1` to keep the collective secure.",
                " When set to `N`, it indicates `(1/N)^t` of staked is decayed at weight",
                " increment step `t`. 0 will result in no weight being added at all (normal",
                " approval voting). A reasonable default value is 24."
              ]
            },
            {
              "name": "VOTER_SET_SIZE",
              "type": "u32",
              "value": "0x40000000",
              "documentation": [
                " The chunk size of the voter vector."
              ]
            },
            {
              "name": "APPROVAL_SET_SIZE",
              "type": "u32",
              "value": "0x08000000",
              "documentation": [
                " The chunk size of the approval vector."
              ]
            }
          ]
        },
        {
          "name": "TechnicalMembership",
          "storage": {
            "prefix": "Instance1Membership",
            "items": [
              {
                "name": "Members",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<AccountId>"
                },
                "fallback": "0x00",
                "documentation": [
                  " The current membership, stored as an ordered Vec."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "add_member",
              "args": [
                {
                  "name": "who",
                  "type": "AccountId"
                }
              ],
              "documentation": [
                " Add a member `who` to the set.",
                "",
                " May only be called from `AddOrigin` or root."
              ]
            },
            {
              "name": "remove_member",
              "args": [
                {
                  "name": "who",
                  "type": "AccountId"
                }
              ],
              "documentation": [
                " Remove a member `who` from the set.",
                "",
                " May only be called from `RemoveOrigin` or root."
              ]
            },
            {
              "name": "swap_member",
              "args": [
                {
                  "name": "remove",
                  "type": "AccountId"
                },
                {
                  "name": "add",
                  "type": "AccountId"
                }
              ],
              "documentation": [
                " Swap out one member `remove` for another `add`.",
                "",
                " May only be called from `SwapOrigin` or root."
              ]
            },
            {
              "name": "reset_members",
              "args": [
                {
                  "name": "members",
                  "type": "Vec<AccountId>"
                }
              ],
              "documentation": [
                " Change the membership to a new set, disregarding the existing membership. Be nice and",
                " pass `members` pre-sorted.",
                "",
                " May only be called from `ResetOrigin` or root."
              ]
            }
          ],
          "events": [
            {
              "name": "MemberAdded",
              "args": [],
              "documentation": [
                " The given member was added; see the transaction for who."
              ]
            },
            {
              "name": "MemberRemoved",
              "args": [],
              "documentation": [
                " The given member was removed; see the transaction for who."
              ]
            },
            {
              "name": "MembersSwapped",
              "args": [],
              "documentation": [
                " Two members were swapped; see the transaction for who."
              ]
            },
            {
              "name": "MembersReset",
              "args": [],
              "documentation": [
                " The membership was reset; see the transaction for who the new set is."
              ]
            },
            {
              "name": "Dummy",
              "args": [
                "PhantomData"
              ],
              "documentation": [
                " Phantom member, never used."
              ]
            }
          ],
          "constants": []
        },
        {
          "name": "Treasury",
          "storage": {
            "prefix": "Treasury",
            "items": [
              {
                "name": "ProposalCount",
                "modifier": "default",
                "type": {
                  "Plain": "ProposalIndex"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " Number of proposals that have been made."
                ]
              },
              {
                "name": "Proposals",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "ProposalIndex",
                    "value": "TreasuryProposal",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Proposals that have been made."
                ]
              },
              {
                "name": "Approvals",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<ProposalIndex>"
                },
                "fallback": "0x00",
                "documentation": [
                  " Proposal indices that have been approved but not yet awarded."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "propose_spend",
              "args": [
                {
                  "name": "value",
                  "type": "Compact<BalanceOf>"
                },
                {
                  "name": "beneficiary",
                  "type": "Address"
                }
              ],
              "documentation": [
                " Put forward a suggestion for spending. A deposit proportional to the value",
                " is reserved and slashed if the proposal is rejected. It is returned once the",
                " proposal is awarded.",
                "",
                " # <weight>",
                " - O(1).",
                " - Limited storage reads.",
                " - One DB change, one extra DB entry.",
                " # </weight>"
              ]
            },
            {
              "name": "reject_proposal",
              "args": [
                {
                  "name": "proposal_id",
                  "type": "Compact<ProposalIndex>"
                }
              ],
              "documentation": [
                " Reject a proposed spend. The original deposit will be slashed.",
                "",
                " # <weight>",
                " - O(1).",
                " - Limited storage reads.",
                " - One DB clear.",
                " # </weight>"
              ]
            },
            {
              "name": "approve_proposal",
              "args": [
                {
                  "name": "proposal_id",
                  "type": "Compact<ProposalIndex>"
                }
              ],
              "documentation": [
                " Approve a proposal. At a later time, the proposal will be allocated to the beneficiary",
                " and the original deposit will be returned.",
                "",
                " # <weight>",
                " - O(1).",
                " - Limited storage reads.",
                " - One DB change.",
                " # </weight>"
              ]
            }
          ],
          "events": [
            {
              "name": "Proposed",
              "args": [
                "ProposalIndex"
              ],
              "documentation": [
                " New proposal."
              ]
            },
            {
              "name": "Spending",
              "args": [
                "Balance"
              ],
              "documentation": [
                " We have ended a spend period and will now allocate funds."
              ]
            },
            {
              "name": "Awarded",
              "args": [
                "ProposalIndex",
                "Balance",
                "AccountId"
              ],
              "documentation": [
                " Some funds have been allocated."
              ]
            },
            {
              "name": "Burnt",
              "args": [
                "Balance"
              ],
              "documentation": [
                " Some of our funds have been burnt."
              ]
            },
            {
              "name": "Rollover",
              "args": [
                "Balance"
              ],
              "documentation": [
                " Spending has finished; this is the amount that rolls over until next spend."
              ]
            }
          ],
          "constants": [
            {
              "name": "ProposalBond",
              "type": "Permill",
              "value": "0x50c30000",
              "documentation": [
                " Fraction of a proposal's value that should be bonded in order to place the proposal.",
                " An accepted proposal gets these back. A rejected proposal does not."
              ]
            },
            {
              "name": "ProposalBondMinimum",
              "type": "BalanceOf",
              "value": "0x0010a5d4e80000000000000000000000",
              "documentation": [
                " Minimum amount of funds that should be placed in a deposit for making a proposal."
              ]
            },
            {
              "name": "SpendPeriod",
              "type": "BlockNumber",
              "value": "0x00460500",
              "documentation": [
                " Period between successive spends."
              ]
            },
            {
              "name": "Burn",
              "type": "Permill",
              "value": "0x50c30000",
              "documentation": [
                " Percentage of spare funds (if any) that are burnt per spend period."
              ]
            }
          ]
        },
        {
          "name": "Claims",
          "storage": {
            "prefix": "Claims",
            "items": [
              {
                "name": "Claims",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "EthereumAddress",
                    "value": "BalanceOf",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": []
              },
              {
                "name": "Total",
                "modifier": "default",
                "type": {
                  "Plain": "BalanceOf"
                },
                "fallback": "0x00000000000000000000000000000000",
                "documentation": []
              }
            ]
          },
          "calls": [
            {
              "name": "claim",
              "args": [
                {
                  "name": "dest",
                  "type": "AccountId"
                },
                {
                  "name": "ethereum_signature",
                  "type": "EcdsaSignature"
                }
              ],
              "documentation": [
                " Make a claim."
              ]
            }
          ],
          "events": [
            {
              "name": "Claimed",
              "args": [
                "AccountId",
                "EthereumAddress",
                "Balance"
              ],
              "documentation": [
                " Someone claimed some DOTs."
              ]
            }
          ],
          "constants": [
            {
              "name": "Prefix",
              "type": "Bytes",
              "value": "0x7c506179204b534d7320746f20746865204b7573616d61206163636f756e743a",
              "documentation": [
                " The Prefix that is used in signed Ethereum messages for this network"
              ]
            }
          ]
        },
        {
          "name": "Parachains",
          "storage": {
            "prefix": "Parachains",
            "items": [
              {
                "name": "Authorities",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<ValidatorId>"
                },
                "fallback": "0x00",
                "documentation": [
                  " All authorities' keys at the moment."
                ]
              },
              {
                "name": "Parachains",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<ParaId>"
                },
                "fallback": "0x00",
                "documentation": [
                  " Vector of all parachain IDs."
                ]
              },
              {
                "name": "Code",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "ParaId",
                    "value": "Bytes",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " The parachains registered at present."
                ]
              },
              {
                "name": "Heads",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "ParaId",
                    "value": "Bytes",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " The heads of the parachains registered at present."
                ]
              },
              {
                "name": "Watermarks",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "ParaId",
                    "value": "BlockNumber",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " The watermark heights of the parachains registered at present.",
                  " For every parachain, this is the block height from which all messages targeting",
                  " that parachain have been processed. Can be `None` only if the parachain doesn't exist."
                ]
              },
              {
                "name": "UnroutedIngress",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "(BlockNumber,ParaId)",
                    "value": "Vec<(ParaId,Hash)>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Unrouted ingress. Maps (BlockNumber, to_chain) pairs to [(from_chain, egress_root)].",
                  "",
                  " There may be an entry under (i, p) in this map for every i between the parachain's",
                  " watermark and the current block."
                ]
              },
              {
                "name": "RelayDispatchQueue",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "ParaId",
                    "value": "Vec<UpwardMessage>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Messages ready to be dispatched onto the relay chain. It is subject to",
                  " `MAX_MESSAGE_COUNT` and `WATERMARK_MESSAGE_SIZE`."
                ]
              },
              {
                "name": "RelayDispatchQueueSize",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "ParaId",
                    "value": "(u32,u32)",
                    "linked": false
                  }
                },
                "fallback": "0x0000000000000000",
                "documentation": [
                  " Size of the dispatch queues. Separated from actual data in order to avoid costly",
                  " decoding when checking receipt validity. First item in tuple is the count of messages",
                  "\tsecond if the total length (in bytes) of the message payloads."
                ]
              },
              {
                "name": "DidUpdate",
                "modifier": "default",
                "type": {
                  "Plain": "bool"
                },
                "fallback": "0x00",
                "documentation": [
                  " Did the parachain heads get updated in this block?"
                ]
              },
              {
                "name": "NextFreeId",
                "modifier": "default",
                "type": {
                  "Plain": "ParaId"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " The next unused ParaId value."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "set_heads",
              "args": [
                {
                  "name": "heads",
                  "type": "Vec<AttestedCandidate>"
                }
              ],
              "documentation": [
                " Provide candidate receipts for parachains, in ascending order by id."
              ]
            },
            {
              "name": "register_parachain",
              "args": [
                {
                  "name": "id",
                  "type": "ParaId"
                },
                {
                  "name": "code",
                  "type": "Bytes"
                },
                {
                  "name": "initial_head_data",
                  "type": "Bytes"
                }
              ],
              "documentation": [
                " Register a parachain with given code.",
                " Fails if given ID is already used."
              ]
            },
            {
              "name": "deregister_parachain",
              "args": [
                {
                  "name": "id",
                  "type": "ParaId"
                }
              ],
              "documentation": [
                " Deregister a parachain with given id"
              ]
            }
          ],
          "events": null,
          "constants": []
        },
        {
          "name": "Attestations",
          "storage": {
            "prefix": "Attestations",
            "items": [
              {
                "name": "RecentParaBlocks",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "BlockNumber",
                    "value": "IncludedBlocks",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " A mapping from modular block number (n % AttestationPeriod)",
                  " to session index and the list of candidate hashes."
                ]
              },
              {
                "name": "ParaBlockAttestations",
                "modifier": "optional",
                "type": {
                  "DoubleMap": {
                    "hasher": "blake2256",
                    "key1": "BlockNumber",
                    "key2": "Hash",
                    "value": "BlockAttestations",
                    "key2Hasher": "blake2128"
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Attestations on a recent parachain block."
                ]
              },
              {
                "name": "DidUpdate",
                "modifier": "default",
                "type": {
                  "Plain": "bool"
                },
                "fallback": "0x00",
                "documentation": []
              }
            ]
          },
          "calls": [
            {
              "name": "more_attestations",
              "args": [
                {
                  "name": "_more",
                  "type": "MoreAttestations"
                }
              ],
              "documentation": [
                " Provide candidate receipts for parachains, in ascending order by id."
              ]
            }
          ],
          "events": null,
          "constants": []
        },
        {
          "name": "Slots",
          "storage": {
            "prefix": "Slots",
            "items": [
              {
                "name": "AuctionCounter",
                "modifier": "default",
                "type": {
                  "Plain": "AuctionIndex"
                },
                "fallback": "0x00000000",
                "documentation": [
                  " The number of auctions that been started so far."
                ]
              },
              {
                "name": "ManagedIds",
                "modifier": "default",
                "type": {
                  "Plain": "Vec<ParaIdOf>"
                },
                "fallback": "0x00",
                "documentation": [
                  " All `ParaId` values that are managed by this module. This includes chains that are not",
                  " yet deployed (but have won an auction in the future)."
                ]
              },
              {
                "name": "Deposits",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "ParaIdOf",
                    "value": "Vec<BalanceOf>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Various amounts on deposit for each parachain. An entry in `ManagedIds` implies a non-",
                  " default entry here.",
                  "",
                  " The actual amount locked on its behalf at any time is the maximum item in this list. The",
                  " first item in the list is the amount locked for the current Lease Period. Following",
                  " items are for the subsequent lease periods.",
                  "",
                  " The default value (an empty list) implies that the parachain no longer exists (or never",
                  " existed) as far as this module is concerned.",
                  "",
                  " If a parachain doesn't exist *yet* but is scheduled to exist in the future, then it",
                  " will be left-padded with one or more zeroes to denote the fact that nothing is held on",
                  " deposit for the non-existent chain currently, but is held at some point in the future."
                ]
              },
              {
                "name": "AuctionInfo",
                "modifier": "optional",
                "type": {
                  "Plain": "(LeasePeriodOf,BlockNumber)"
                },
                "fallback": "0x00",
                "documentation": [
                  " Information relating to the current auction, if there is one.",
                  "",
                  " The first item in the tuple is the lease period index that the first of the four",
                  " contiguous lease periods on auction is for. The second is the block number when the",
                  " auction will \"begin to end\", i.e. the first block of the Ending Period of the auction."
                ]
              },
              {
                "name": "Winning",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "BlockNumber",
                    "value": "WinningData",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " The winning bids for each of the 10 ranges at each block in the final Ending Period of",
                  " the current auction. The map's key is the 0-based index into the Ending Period. The",
                  " first block of the ending period is 0; the last is `EndingPeriod - 1`."
                ]
              },
              {
                "name": "ReservedAmounts",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "Bidder",
                    "value": "BalanceOf",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " Amounts currently reserved in the accounts of the bidders currently winning",
                  " (sub-)ranges."
                ]
              },
              {
                "name": "OnboardQueue",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "LeasePeriodOf",
                    "value": "Vec<ParaIdOf>",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " The set of Para IDs that have won and need to be on-boarded at an upcoming lease-period.",
                  " This is cleared out on the first block of the lease period."
                ]
              },
              {
                "name": "Onboarding",
                "modifier": "optional",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "ParaIdOf",
                    "value": "(LeasePeriodOf,IncomingParachain)",
                    "linked": false
                  }
                },
                "fallback": "0x00",
                "documentation": [
                  " The actual on-boarding information. Only exists when one of the following is true:",
                  " - It is before the lease period that the parachain should be on-boarded.",
                  " - The full on-boarding information has not yet been provided and the parachain is not",
                  " yet due to be off-boarded."
                ]
              },
              {
                "name": "Offboarding",
                "modifier": "default",
                "type": {
                  "Map": {
                    "hasher": "blake2256",
                    "key": "ParaIdOf",
                    "value": "AccountId",
                    "linked": false
                  }
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "documentation": [
                  " Off-boarding account; currency held on deposit for the parachain gets placed here if the",
                  " parachain gets off-boarded; i.e. its lease period is up and it isn't renewed."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "new_auction",
              "args": [
                {
                  "name": "duration",
                  "type": "Compact<BlockNumber>"
                },
                {
                  "name": "lease_period_index",
                  "type": "Compact<LeasePeriodOf>"
                }
              ],
              "documentation": [
                " Create a new auction.",
                "",
                " This can only happen when there isn't already an auction in progress and may only be",
                " called by the root origin. Accepts the `duration` of this auction and the",
                " `lease_period_index` of the initial lease period of the four that are to be auctioned."
              ]
            },
            {
              "name": "bid",
              "args": [
                {
                  "name": "sub",
                  "type": "Compact<SubId>"
                },
                {
                  "name": "auction_index",
                  "type": "Compact<AuctionIndex>"
                },
                {
                  "name": "first_slot",
                  "type": "Compact<LeasePeriodOf>"
                },
                {
                  "name": "last_slot",
                  "type": "Compact<LeasePeriodOf>"
                },
                {
                  "name": "amount",
                  "type": "Compact<BalanceOf>"
                }
              ],
              "documentation": [
                " Make a new bid from an account (including a parachain account) for deploying a new",
                " parachain.",
                "",
                " Multiple simultaneous bids from the same bidder are allowed only as long as all active",
                " bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.",
                "",
                " - `sub` is the sub-bidder ID, allowing for multiple competing bids to be made by (and",
                " funded by) the same account.",
                " - `auction_index` is the index of the auction to bid on. Should just be the present",
                " value of `AuctionCounter`.",
                " - `first_slot` is the first lease period index of the range to bid on. This is the",
                " absolute lease period index value, not an auction-specific offset.",
                " - `last_slot` is the last lease period index of the range to bid on. This is the",
                " absolute lease period index value, not an auction-specific offset.",
                " - `amount` is the amount to bid to be held as deposit for the parachain should the",
                " bid win. This amount is held throughout the range."
              ]
            },
            {
              "name": "bid_renew",
              "args": [
                {
                  "name": "auction_index",
                  "type": "Compact<AuctionIndex>"
                },
                {
                  "name": "first_slot",
                  "type": "Compact<LeasePeriodOf>"
                },
                {
                  "name": "last_slot",
                  "type": "Compact<LeasePeriodOf>"
                },
                {
                  "name": "amount",
                  "type": "Compact<BalanceOf>"
                }
              ],
              "documentation": [
                " Make a new bid from a parachain account for renewing that (pre-existing) parachain.",
                "",
                " The origin *must* be a parachain account.",
                "",
                " Multiple simultaneous bids from the same bidder are allowed only as long as all active",
                " bids overlap each other (i.e. are mutually exclusive). Bids cannot be redacted.",
                "",
                " - `auction_index` is the index of the auction to bid on. Should just be the present",
                " value of `AuctionCounter`.",
                " - `first_slot` is the first lease period index of the range to bid on. This is the",
                " absolute lease period index value, not an auction-specific offset.",
                " - `last_slot` is the last lease period index of the range to bid on. This is the",
                " absolute lease period index value, not an auction-specific offset.",
                " - `amount` is the amount to bid to be held as deposit for the parachain should the",
                " bid win. This amount is held throughout the range."
              ]
            },
            {
              "name": "set_offboarding",
              "args": [
                {
                  "name": "dest",
                  "type": "Address"
                }
              ],
              "documentation": [
                " Set the off-boarding information for a parachain.",
                "",
                " The origin *must* be a parachain account.",
                "",
                " - `dest` is the destination account to receive the parachain's deposit."
              ]
            },
            {
              "name": "fix_deploy_data",
              "args": [
                {
                  "name": "sub",
                  "type": "Compact<SubId>"
                },
                {
                  "name": "para_id",
                  "type": "Compact<ParaIdOf>"
                },
                {
                  "name": "code_hash",
                  "type": "Hash"
                },
                {
                  "name": "initial_head_data",
                  "type": "Bytes"
                }
              ],
              "documentation": [
                " Set the deploy information for a successful bid to deploy a new parachain.",
                "",
                " - `origin` must be the successful bidder account.",
                " - `sub` is the sub-bidder ID of the bidder.",
                " - `para_id` is the parachain ID allotted to the winning bidder.",
                " - `code_hash` is the hash of the parachain's Wasm validation function.",
                " - `initial_head_data` is the parachain's initial head data."
              ]
            },
            {
              "name": "elaborate_deploy_data",
              "args": [
                {
                  "name": "para_id",
                  "type": "Compact<ParaIdOf>"
                },
                {
                  "name": "code",
                  "type": "Bytes"
                }
              ],
              "documentation": [
                " Note a new parachain's code.",
                "",
                " This must be called after `fix_deploy_data` and `code` must be the preimage of the",
                " `code_hash` passed there for the same `para_id`.",
                "",
                " This may be called before or after the beginning of the parachain's first lease period.",
                " If called before then the parachain will become active at the first block of its",
                " starting lease period. If after, then it will become active immediately after this call.",
                "",
                " - `_origin` is irrelevant.",
                " - `para_id` is the parachain ID whose code will be elaborated.",
                " - `code` is the preimage of the registered `code_hash` of `para_id`."
              ]
            }
          ],
          "events": [
            {
              "name": "NewLeasePeriod",
              "args": [
                "LeasePeriod"
              ],
              "documentation": [
                " A new lease period is beginning."
              ]
            },
            {
              "name": "AuctionStarted",
              "args": [
                "AuctionIndex",
                "LeasePeriod",
                "BlockNumber"
              ],
              "documentation": [
                " An auction started. Provides its index and the block number where it will begin to",
                " close and the first lease period of the quadruplet that is auctioned."
              ]
            },
            {
              "name": "AuctionClosed",
              "args": [
                "AuctionIndex"
              ],
              "documentation": [
                " An auction ended. All funds become unreserved."
              ]
            },
            {
              "name": "WonDeploy",
              "args": [
                "NewBidder",
                "SlotRange",
                "ParaId",
                "Balance"
              ],
              "documentation": [
                " Someone won the right to deploy a parachain. Balance amount is deducted for deposit."
              ]
            },
            {
              "name": "WonRenewal",
              "args": [
                "ParaId",
                "SlotRange",
                "Balance",
                "Balance"
              ],
              "documentation": [
                " An existing parachain won the right to continue."
              ]
            },
            {
              "name": "Reserved",
              "args": [
                "AccountId",
                "Balance",
                "Balance"
              ],
              "documentation": [
                " Funds were reserved for a winning bid. First balance is the extra amount reserved.",
                " Second is the total."
              ]
            },
            {
              "name": "Unreserved",
              "args": [
                "AccountId",
                "Balance"
              ],
              "documentation": [
                " Funds were unreserved since bidder is no longer active."
              ]
            }
          ],
          "constants": []
        },
        {
          "name": "Sudo",
          "storage": {
            "prefix": "Sudo",
            "items": [
              {
                "name": "Key",
                "modifier": "default",
                "type": {
                  "Plain": "AccountId"
                },
                "fallback": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "documentation": [
                  " The `AccountId` of the sudo key."
                ]
              }
            ]
          },
          "calls": [
            {
              "name": "sudo",
              "args": [
                {
                  "name": "proposal",
                  "type": "Proposal"
                }
              ],
              "documentation": [
                " Authenticates the sudo key and dispatches a function call with `Root` origin.",
                "",
                " The dispatch origin for this call must be _Signed_.",
                "",
                " # <weight>",
                " - O(1).",
                " - Limited storage reads.",
                " - One DB write (event).",
                " - Unknown weight of derivative `proposal` execution.",
                " # </weight>"
              ]
            },
            {
              "name": "set_key",
              "args": [
                {
                  "name": "new",
                  "type": "Address"
                }
              ],
              "documentation": [
                " Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.",
                "",
                " The dispatch origin for this call must be _Signed_.",
                "",
                " # <weight>",
                " - O(1).",
                " - Limited storage reads.",
                " - One DB change.",
                " # </weight>"
              ]
            },
            {
              "name": "sudo_as",
              "args": [
                {
                  "name": "who",
                  "type": "Address"
                },
                {
                  "name": "proposal",
                  "type": "Proposal"
                }
              ],
              "documentation": [
                " Authenticates the sudo key and dispatches a function call with `Signed` origin from",
                " a given account.",
                "",
                " The dispatch origin for this call must be _Signed_.",
                "",
                " # <weight>",
                " - O(1).",
                " - Limited storage reads.",
                " - One DB write (event).",
                " - Unknown weight of derivative `proposal` execution.",
                " # </weight>"
              ]
            }
          ],
          "events": [
            {
              "name": "Sudid",
              "args": [
                "bool"
              ],
              "documentation": [
                " A sudo just took place."
              ]
            },
            {
              "name": "KeyChanged",
              "args": [
                "AccountId"
              ],
              "documentation": [
                " The sudoer just switched identity; the old key is supplied."
              ]
            },
            {
              "name": "SudoAsDone",
              "args": [
                "bool"
              ],
              "documentation": [
                " A sudo just took place."
              ]
            }
          ],
          "constants": []
        }
      ]
    }
  }
}
